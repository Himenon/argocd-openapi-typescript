// 
// Generated by @himenon/openapi-typescript-code-generator v1.0.3
// 
// OpenApi : 3.0.0
// 
// 


export namespace Schemas {
    export interface accountAccount {
        capabilities?: string[];
        enabled?: boolean;
        name?: string;
        tokens?: Schemas.accountToken[];
    }
    export interface accountAccountsList {
        items?: Schemas.accountAccount[];
    }
    export interface accountCanIResponse {
        value?: string;
    }
    export interface accountCreateTokenRequest {
        /** expiresIn represents a duration in seconds */
        expiresIn?: string;
        id?: string;
        name?: string;
    }
    export interface accountCreateTokenResponse {
        token?: string;
    }
    export interface accountEmptyResponse {
    }
    export interface accountToken {
        expiresAt?: string;
        id?: string;
        issuedAt?: string;
    }
    export interface accountUpdatePasswordRequest {
        currentPassword?: string;
        name?: string;
        newPassword?: string;
    }
    export interface accountUpdatePasswordResponse {
    }
    export interface applicationApplicationPatchRequest {
        name?: string;
        patch?: string;
        patchType?: string;
    }
    export interface applicationApplicationResourceResponse {
        manifest?: string;
    }
    export interface applicationApplicationResponse {
    }
    export interface applicationApplicationRollbackRequest {
        dryRun?: boolean;
        id?: string;
        name?: string;
        prune?: boolean;
    }
    export interface applicationApplicationSyncRequest {
        dryRun?: boolean;
        infos?: Schemas.v1alpha1Info[];
        manifests?: string[];
        name?: string;
        prune?: boolean;
        resources?: Schemas.v1alpha1SyncOperationResource[];
        retryStrategy?: Schemas.v1alpha1RetryStrategy;
        revision?: string;
        strategy?: Schemas.v1alpha1SyncStrategy;
        syncOptions?: Schemas.applicationSyncOptions;
    }
    export interface applicationApplicationSyncWindow {
        duration?: string;
        kind?: string;
        manualSync?: boolean;
        schedule?: string;
    }
    export interface applicationApplicationSyncWindowsResponse {
        activeWindows?: Schemas.applicationApplicationSyncWindow[];
        assignedWindows?: Schemas.applicationApplicationSyncWindow[];
        canSync?: boolean;
    }
    export interface applicationLogEntry {
        content?: string;
        last?: boolean;
        podName?: string;
        timeStamp?: Schemas.v1Time;
        timeStampStr?: string;
    }
    export interface applicationManagedResourcesResponse {
        items?: Schemas.v1alpha1ResourceDiff[];
    }
    export interface applicationOperationTerminateResponse {
    }
    export interface applicationResourceActionsListResponse {
        actions?: Schemas.v1alpha1ResourceAction[];
    }
    export interface applicationSyncOptions {
        items?: string[];
    }
    export interface applicationv1alpha1EnvEntry {
        /** Name is the name of the variable, usually expressed in uppercase */
        name?: string;
        /** Value is the value of the variable */
        value?: string;
    }
    export interface clusterClusterResponse {
    }
    export interface clusterConnector {
        name?: string;
        type?: string;
    }
    export interface clusterDexConfig {
        connectors?: Schemas.clusterConnector[];
    }
    export interface clusterGoogleAnalyticsConfig {
        anonymizeUsers?: boolean;
        trackingID?: string;
    }
    export interface clusterHelp {
        /** the text for getting chat help, defaults to "Chat now!" */
        chatText?: string;
        /** the URL for getting chat help, this will typically be your Slack channel for support */
        chatUrl?: string;
    }
    export interface clusterOIDCConfig {
        cliClientID?: string;
        clientID?: string;
        idTokenClaims?: {
            [key: string]: Schemas.oidcClaim;
        };
        issuer?: string;
        name?: string;
        scopes?: string[];
    }
    export interface clusterPlugin {
        /** the name of the plugin, e.g. "kasane" */
        name?: string;
    }
    export interface clusterSettings {
        appLabelKey?: string;
        configManagementPlugins?: Schemas.v1alpha1ConfigManagementPlugin[];
        dexConfig?: Schemas.clusterDexConfig;
        googleAnalytics?: Schemas.clusterGoogleAnalyticsConfig;
        help?: Schemas.clusterHelp;
        kustomizeOptions?: Schemas.v1alpha1KustomizeOptions;
        kustomizeVersions?: string[];
        oidcConfig?: Schemas.clusterOIDCConfig;
        passwordPattern?: string;
        plugins?: Schemas.clusterPlugin[];
        resourceOverrides?: {
            [key: string]: Schemas.v1alpha1ResourceOverride;
        };
        statusBadgeEnabled?: boolean;
        trackingMethod?: string;
        uiBannerContent?: string;
        uiBannerPermanent?: boolean;
        uiBannerPosition?: string;
        uiBannerURL?: string;
        uiCssURL?: string;
        url?: string;
        userLoginsDisabled?: boolean;
    }
    export interface gpgkeyGnuPGPublicKeyCreateResponse {
        created?: Schemas.v1alpha1GnuPGPublicKeyList;
        /** List of key IDs that haven been skipped because they already exist on the server */
        skipped?: string[];
    }
    export interface gpgkeyGnuPGPublicKeyResponse {
    }
    export interface oidcClaim {
        essential?: boolean;
        value?: string;
        values?: string[];
    }
    export interface projectDetailedProjectsResponse {
        clusters?: Schemas.v1alpha1Cluster[];
        globalProjects?: Schemas.v1alpha1AppProject[];
        project?: Schemas.v1alpha1AppProject;
        repositories?: Schemas.v1alpha1Repository[];
    }
    export interface projectEmptyResponse {
    }
    export interface projectGlobalProjectsResponse {
        items?: Schemas.v1alpha1AppProject[];
    }
    /** ProjectCreateRequest defines project creation parameters. */
    export interface projectProjectCreateRequest {
        project?: Schemas.v1alpha1AppProject;
        upsert?: boolean;
    }
    /** ProjectTokenCreateRequest defines project token creation parameters. */
    export interface projectProjectTokenCreateRequest {
        description?: string;
        /** expiresIn represents a duration in seconds */
        expiresIn?: string;
        id?: string;
        project?: string;
        role?: string;
    }
    /** ProjectTokenResponse wraps the created token or returns an empty string if deleted. */
    export interface projectProjectTokenResponse {
        token?: string;
    }
    export interface projectProjectUpdateRequest {
        project?: Schemas.v1alpha1AppProject;
    }
    export interface projectSyncWindowsResponse {
        windows?: Schemas.v1alpha1SyncWindow[];
    }
    export interface protobufAny {
        type_url?: string;
        value?: Blob;
    }
    export interface repocredsRepoCredsResponse {
    }
    export interface repositoryAppInfo {
        path?: string;
        type?: string;
    }
    export interface repositoryDirectoryAppSpec {
    }
    export interface repositoryHelmAppSpec {
        /** helm file parameters */
        fileParameters?: Schemas.v1alpha1HelmFileParameter[];
        name?: string;
        /** the output of `helm inspect values` */
        parameters?: Schemas.v1alpha1HelmParameter[];
        valueFiles?: string[];
        /** the contents of values.yaml */
        values?: string;
    }
    export interface repositoryHelmChart {
        name?: string;
        versions?: string[];
    }
    export interface repositoryHelmChartsResponse {
        items?: Schemas.repositoryHelmChart[];
    }
    export interface repositoryKsonnetAppSpec {
        environments?: {
            [key: string]: Schemas.repositoryKsonnetEnvironment;
        };
        name?: string;
        parameters?: Schemas.v1alpha1KsonnetParameter[];
    }
    export interface repositoryKsonnetEnvironment {
        destination?: Schemas.repositoryKsonnetEnvironmentDestination;
        /** KubernetesVersion is the kubernetes version the targeted cluster is running on. */
        k8sVersion?: string;
        /** Name is the user defined name of an environment */
        name?: string;
    }
    export interface repositoryKsonnetEnvironmentDestination {
        /** Namespace is the namespace of the Kubernetes server that targets should be deployed to */
        namespace?: string;
        /** Server is the Kubernetes server that the cluster is running on. */
        server?: string;
    }
    export interface repositoryKustomizeAppSpec {
        /** images is a list of available images. */
        images?: string[];
    }
    export interface repositoryManifestResponse {
        manifests?: string[];
        namespace?: string;
        /** resolved revision */
        revision?: string;
        server?: string;
        sourceType?: string;
        /** Raw response of git verify-commit operation (always the empty string for Helm) */
        verifyResult?: string;
    }
    export interface repositoryRefs {
        branches?: string[];
        tags?: string[];
    }
    export interface repositoryRepoAppDetailsQuery {
        appName?: string;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface repositoryRepoAppDetailsResponse {
        directory?: Schemas.repositoryDirectoryAppSpec;
        helm?: Schemas.repositoryHelmAppSpec;
        ksonnet?: Schemas.repositoryKsonnetAppSpec;
        kustomize?: Schemas.repositoryKustomizeAppSpec;
        type?: string;
    }
    export interface repositoryRepoAppsResponse {
        items?: Schemas.repositoryAppInfo[];
    }
    export interface repositoryRepoResponse {
    }
    export interface runtimeError {
        code?: number;
        details?: Schemas.protobufAny[];
        error?: string;
        message?: string;
    }
    export interface runtimeStreamError {
        details?: Schemas.protobufAny[];
        grpc_code?: number;
        http_code?: number;
        http_status?: string;
        message?: string;
    }
    export interface sessionGetUserInfoResponse {
        groups?: string[];
        iss?: string;
        loggedIn?: boolean;
        username?: string;
    }
    /** SessionCreateRequest is for logging in. */
    export interface sessionSessionCreateRequest {
        password?: string;
        token?: string;
        username?: string;
    }
    /** SessionResponse wraps the created token or returns an empty string if deleted. */
    export interface sessionSessionResponse {
        token?: string;
    }
    /**
     * Event is a report of an event somewhere in the cluster.  Events
     * have a limited retention time and triggers and messages may evolve
     * with time.  Event consumers should not rely on the timing of an event
     * with a given Reason reflecting a consistent underlying trigger, or the
     * continued existence of events with that Reason.  Events should be
     * treated as informative, best-effort, supplemental data.
     */
    export interface v1Event {
        /**
         * What action was taken/failed regarding to the Regarding object.
         * +optional
         */
        action?: string;
        /**
         * The number of times this event has occurred.
         * +optional
         */
        count?: number;
        eventTime?: Schemas.v1MicroTime;
        firstTimestamp?: Schemas.v1Time;
        involvedObject?: Schemas.v1ObjectReference;
        lastTimestamp?: Schemas.v1Time;
        /**
         * A human-readable description of the status of this operation.
         * TODO: decide on maximum length.
         * +optional
         */
        message?: string;
        metadata?: Schemas.v1ObjectMeta;
        /**
         * This should be a short, machine understandable string that gives the reason
         * for the transition into the object's current status.
         * TODO: provide exact specification for format.
         * +optional
         */
        reason?: string;
        related?: Schemas.v1ObjectReference;
        /**
         * Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
         * +optional
         */
        reportingComponent?: string;
        /**
         * ID of the controller instance, e.g. `kubelet-xyzf`.
         * +optional
         */
        reportingInstance?: string;
        series?: Schemas.v1EventSeries;
        source?: Schemas.v1EventSource;
        /**
         * Type of this event (Normal, Warning), new types could be added in the future
         * +optional
         */
        type?: string;
    }
    /** EventList is a list of events. */
    export interface v1EventList {
        /** List of events */
        items?: Schemas.v1Event[];
        metadata?: Schemas.v1ListMeta;
    }
    /**
     * EventSeries contain information on series of events, i.e. thing that was/is happening
     * continuously for some time.
     */
    export interface v1EventSeries {
        /** Number of occurrences in this series up to the last heartbeat time */
        count?: number;
        lastObservedTime?: Schemas.v1MicroTime;
    }
    /** EventSource contains information for an event. */
    export interface v1EventSource {
        /**
         * Component from which the event is generated.
         * +optional
         */
        component?: string;
        /**
         * Node name on which the event is generated.
         * +optional
         */
        host?: string;
    }
    /**
     * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
     *
     * Each key is either a '.' representing the field itself, and will always map to an empty set,
     * or a string representing a sub-field or item. The string will follow one of these four formats:
     * 'f:<name>', where <name> is the name of a field in a struct, or key in a map
     * 'v:<value>', where <value> is the exact json formatted value of a list item
     * 'i:<index>', where <index> is position of a item in a list
     * 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
     * If a key maps to an empty Fields value, the field that key represents is part of the set.
     *
     * The exact format is defined in sigs.k8s.io/structured-merge-diff
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface v1FieldsV1 {
        /** Raw is the underlying serialization of this object. */
        Raw?: Blob;
    }
    /** +protobuf.options.(gogoproto.goproto_stringer)=false */
    export interface v1GroupKind {
        group?: string;
        kind?: string;
    }
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and
     * various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    export interface v1ListMeta {
        /**
         * continue may be set if the user set a limit on the number of items returned, and indicates that
         * the server has more data available. The value is opaque and may be used to issue another request
         * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
         * consistent list may not be possible if the server configuration has changed or more than a few
         * minutes have passed. The resourceVersion field returned when using this continue value will be
         * identical to the value in the first response, unless you have received this token from an error
         * message.
         */
        continue?: string;
        /**
         * remainingItemCount is the number of subsequent items in the list which are not included in this
         * list response. If the list request contained label or field selectors, then the number of
         * remaining items is unknown and the field will be left unset and omitted during serialization.
         * If the list is complete (either because it is not chunking or because this is the last chunk),
         * then there are no more remaining items and this field will be left unset and omitted during
         * serialization.
         * Servers older than v1.15 do not set this field.
         * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
         * should not rely on the remainingItemCount to be set or to be exact.
         * +optional
         */
        remainingItemCount?: string;
        /**
         * String that identifies the server's internal version of this object that
         * can be used by clients to determine when objects have changed.
         * Value must be treated as opaque by clients and passed unmodified back to the server.
         * Populated by the system.
         * Read-only.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
         * +optional
         */
        resourceVersion?: string;
        /**
         * selfLink is a URL representing this object.
         * Populated by the system.
         * Read-only.
         *
         * DEPRECATED
         * Kubernetes will stop propagating this field in 1.20 release and the field is planned
         * to be removed in 1.21 release.
         * +optional
         */
        selfLink?: string;
    }
    /**
     * LoadBalancerIngress represents the status of a load-balancer ingress point:
     * traffic intended for the service should be sent to an ingress point.
     */
    export interface v1LoadBalancerIngress {
        /**
         * Hostname is set for load-balancer ingress points that are DNS based
         * (typically AWS load-balancers)
         * +optional
         */
        hostname?: string;
        /**
         * IP is set for load-balancer ingress points that are IP based
         * (typically GCE or OpenStack load-balancers)
         * +optional
         */
        ip?: string;
        /**
         * Ports is a list of records of service ports
         * If used, every port defined in the service should have an entry in it
         * +listType=atomic
         * +optional
         */
        ports?: Schemas.v1PortStatus[];
    }
    /**
     * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
     * that the fieldset applies to.
     */
    export interface v1ManagedFieldsEntry {
        /**
         * APIVersion defines the version of this resource that this field set
         * applies to. The format is "group/version" just like the top-level
         * APIVersion field. It is necessary to track the version of a field
         * set because it cannot be automatically converted.
         */
        apiVersion?: string;
        /**
         * FieldsType is the discriminator for the different fields format and version.
         * There is currently only one possible value: "FieldsV1"
         */
        fieldsType?: string;
        fieldsV1?: Schemas.v1FieldsV1;
        /** Manager is an identifier of the workflow managing these fields. */
        manager?: string;
        /**
         * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
         * The only valid values for this field are 'Apply' and 'Update'.
         */
        operation?: string;
        /**
         * Subresource is the name of the subresource used to update that object, or
         * empty string if the object was updated through the main resource. The
         * value of this field is used to distinguish between managers, even if they
         * share the same name. For example, a status update will be distinct from a
         * regular update using the same manager name.
         * Note that the APIVersion field is not related to the Subresource field and
         * it always corresponds to the version of the main resource.
         */
        subresource?: string;
        time?: Schemas.v1Time;
    }
    /**
     * MicroTime is version of Time with microsecond level precision.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface v1MicroTime {
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive. This field may be limited in precision depending on context.
         */
        nanos?: number;
        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: string;
    }
    /** NodeSystemInfo is a set of ids/uuids to uniquely identify the node. */
    export interface v1NodeSystemInfo {
        /** The Architecture reported by the node */
        architecture?: string;
        /** Boot ID reported by the node. */
        bootID?: string;
        /** ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0). */
        containerRuntimeVersion?: string;
        /** Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64). */
        kernelVersion?: string;
        /** KubeProxy Version reported by the node. */
        kubeProxyVersion?: string;
        /** Kubelet Version reported by the node. */
        kubeletVersion?: string;
        /**
         * MachineID reported by the node. For unique machine identification
         * in the cluster this field is preferred. Learn more from man(5)
         * machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
         */
        machineID?: string;
        /** The Operating System reported by the node */
        operatingSystem?: string;
        /** OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)). */
        osImage?: string;
        /**
         * SystemUUID reported by the node. For unique machine identification
         * MachineID is preferred. This field is specific to Red Hat hosts
         * https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
         */
        systemUUID?: string;
    }
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects
     * users must create.
     */
    export interface v1ObjectMeta {
        /**
         * Annotations is an unstructured key value map stored with a resource that may be
         * set by external tools to store and retrieve arbitrary metadata. They are not
         * queryable and should be preserved when modifying objects.
         * More info: http://kubernetes.io/docs/user-guide/annotations
         * +optional
         */
        annotations?: {
            [key: string]: string;
        };
        /**
         * The name of the cluster which the object belongs to.
         * This is used to distinguish resources with same name and namespace in different clusters.
         * This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
         * +optional
         */
        clusterName?: string;
        creationTimestamp?: Schemas.v1Time;
        /**
         * Number of seconds allowed for this object to gracefully terminate before
         * it will be removed from the system. Only set when deletionTimestamp is also set.
         * May only be shortened.
         * Read-only.
         * +optional
         */
        deletionGracePeriodSeconds?: string;
        deletionTimestamp?: Schemas.v1Time;
        /**
         * Must be empty before the object is deleted from the registry. Each entry
         * is an identifier for the responsible component that will remove the entry
         * from the list. If the deletionTimestamp of the object is non-nil, entries
         * in this list can only be removed.
         * Finalizers may be processed and removed in any order.  Order is NOT enforced
         * because it introduces significant risk of stuck finalizers.
         * finalizers is a shared field, any actor with permission can reorder it.
         * If the finalizer list is processed in order, then this can lead to a situation
         * in which the component responsible for the first finalizer in the list is
         * waiting for a signal (field value, external system, or other) produced by a
         * component responsible for a finalizer later in the list, resulting in a deadlock.
         * Without enforced ordering finalizers are free to order amongst themselves and
         * are not vulnerable to ordering changes in the list.
         * +optional
         * +patchStrategy=merge
         */
        finalizers?: string[];
        /**
         * GenerateName is an optional prefix, used by the server, to generate a unique
         * name ONLY IF the Name field has not been provided.
         * If this field is used, the name returned to the client will be different
         * than the name passed. This value will also be combined with a unique suffix.
         * The provided value has the same validation rules as the Name field,
         * and may be truncated by the length of the suffix required to make the value
         * unique on the server.
         *
         * If this field is specified and the generated name exists, the server will
         * NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
         * ServerTimeout indicating a unique name could not be found in the time allotted, and the client
         * should retry (optionally after the time indicated in the Retry-After header).
         *
         * Applied only if Name is not specified.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
         * +optional
         */
        generateName?: string;
        /**
         * A sequence number representing a specific generation of the desired state.
         * Populated by the system. Read-only.
         * +optional
         */
        generation?: string;
        /**
         * Map of string keys and values that can be used to organize and categorize
         * (scope and select) objects. May match selectors of replication controllers
         * and services.
         * More info: http://kubernetes.io/docs/user-guide/labels
         * +optional
         */
        labels?: {
            [key: string]: string;
        };
        /**
         * ManagedFields maps workflow-id and version to the set of fields
         * that are managed by that workflow. This is mostly for internal
         * housekeeping, and users typically shouldn't need to set or
         * understand this field. A workflow can be the user's name, a
         * controller's name, or the name of a specific apply path like
         * "ci-cd". The set of fields is always in the version that the
         * workflow used when modifying the object.
         *
         * +optional
         */
        managedFields?: Schemas.v1ManagedFieldsEntry[];
        /**
         * Name must be unique within a namespace. Is required when creating resources, although
         * some resources may allow a client to request the generation of an appropriate name
         * automatically. Name is primarily intended for creation idempotence and configuration
         * definition.
         * Cannot be updated.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#names
         * +optional
         */
        name?: string;
        /**
         * Namespace defines the space within which each name must be unique. An empty namespace is
         * equivalent to the "default" namespace, but "default" is the canonical representation.
         * Not all objects are required to be scoped to a namespace - the value of this field for
         * those objects will be empty.
         *
         * Must be a DNS_LABEL.
         * Cannot be updated.
         * More info: http://kubernetes.io/docs/user-guide/namespaces
         * +optional
         */
        namespace?: string;
        /**
         * List of objects depended by this object. If ALL objects in the list have
         * been deleted, this object will be garbage collected. If this object is managed by a controller,
         * then an entry in this list will point to this controller, with the controller field set to true.
         * There cannot be more than one managing controller.
         * +optional
         * +patchMergeKey=uid
         * +patchStrategy=merge
         */
        ownerReferences?: Schemas.v1OwnerReference[];
        /**
         * An opaque value that represents the internal version of this object that can
         * be used by clients to determine when objects have changed. May be used for optimistic
         * concurrency, change detection, and the watch operation on a resource or set of resources.
         * Clients must treat these values as opaque and passed unmodified back to the server.
         * They may only be valid for a particular resource or set of resources.
         *
         * Populated by the system.
         * Read-only.
         * Value must be treated as opaque by clients and .
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
         * +optional
         */
        resourceVersion?: string;
        /**
         * SelfLink is a URL representing this object.
         * Populated by the system.
         * Read-only.
         *
         * DEPRECATED
         * Kubernetes will stop propagating this field in 1.20 release and the field is planned
         * to be removed in 1.21 release.
         * +optional
         */
        selfLink?: string;
        /**
         * UID is the unique in time and space value for this object. It is typically generated by
         * the server on successful creation of a resource and is not allowed to change on PUT
         * operations.
         *
         * Populated by the system.
         * Read-only.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
         * +optional
         */
        uid?: string;
    }
    export interface v1ObjectReference {
        /**
         * API version of the referent.
         * +optional
         */
        apiVersion?: string;
        /**
         * If referring to a piece of an object instead of an entire object, this string
         * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
         * For example, if the object reference is to a container within a pod, this would take on a value like:
         * "spec.containers{name}" (where "name" refers to the name of the container that triggered
         * the event) or if no container name is specified "spec.containers[2]" (container with
         * index 2 in this pod). This syntax is chosen only to have some well-defined way of
         * referencing a part of an object.
         * TODO: this design is not final and this field is subject to change in the future.
         * +optional
         */
        fieldPath?: string;
        /**
         * Kind of the referent.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
         * +optional
         */
        kind?: string;
        /**
         * Name of the referent.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
         * +optional
         */
        name?: string;
        /**
         * Namespace of the referent.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
         * +optional
         */
        namespace?: string;
        /**
         * Specific resourceVersion to which this reference is made, if any.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
         * +optional
         */
        resourceVersion?: string;
        /**
         * UID of the referent.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
         * +optional
         */
        uid?: string;
    }
    export interface v1OwnerReference {
        /** API version of the referent. */
        apiVersion?: string;
        /**
         * If true, AND if the owner has the "foregroundDeletion" finalizer, then
         * the owner cannot be deleted from the key-value store until this
         * reference is removed.
         * Defaults to false.
         * To set this field, a user needs "delete" permission of the owner,
         * otherwise 422 (Unprocessable Entity) will be returned.
         * +optional
         */
        blockOwnerDeletion?: boolean;
        /**
         * If true, this reference points to the managing controller.
         * +optional
         */
        controller?: boolean;
        /**
         * Kind of the referent.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
         */
        kind?: string;
        /**
         * Name of the referent.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#names
         */
        name?: string;
        /**
         * UID of the referent.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
         */
        uid?: string;
    }
    export interface v1PortStatus {
        /**
         * Error is to record the problem with the service port
         * The format of the error shall comply with the following rules:
         * - built-in error values shall be specified in this file and those shall use
         *   CamelCase names
         * - cloud provider specific error values must have names that comply with the
         *   format foo.example.com/CamelCase.
         * ---
         * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
         * +optional
         * +kubebuilder:validation:Required
         * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)\*\\/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
         * +kubebuilder:validation:MaxLength=316
         */
        error?: string;
        /** Port is the port number of the service port of which status is recorded here */
        port?: number;
        /**
         * Protocol is the protocol of the service port of which status is recorded here
         * The supported values are: "TCP", "UDP", "SCTP"
         */
        protocol?: string;
    }
    /**
     * Time is a wrapper around time.Time which supports correct
     * marshaling to YAML and JSON.  Wrappers are provided for many
     * of the factory methods that the time package offers.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface v1Time {
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive. This field may be limited in precision depending on context.
         */
        nanos?: number;
        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: string;
    }
    export interface v1alpha1AWSAuthConfig {
        /** ClusterName contains AWS cluster name */
        clusterName?: string;
        /** RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain. */
        roleARN?: string;
    }
    export interface v1alpha1AppProject {
        metadata?: Schemas.v1ObjectMeta;
        spec?: Schemas.v1alpha1AppProjectSpec;
        status?: Schemas.v1alpha1AppProjectStatus;
    }
    export interface v1alpha1AppProjectList {
        items?: Schemas.v1alpha1AppProject[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1AppProjectSpec {
        /** ClusterResourceBlacklist contains list of blacklisted cluster level resources */
        clusterResourceBlacklist?: Schemas.v1GroupKind[];
        /** ClusterResourceWhitelist contains list of whitelisted cluster level resources */
        clusterResourceWhitelist?: Schemas.v1GroupKind[];
        /** Description contains optional project description */
        description?: string;
        /** Destinations contains list of destinations available for deployment */
        destinations?: Schemas.v1alpha1ApplicationDestination[];
        /** NamespaceResourceBlacklist contains list of blacklisted namespace level resources */
        namespaceResourceBlacklist?: Schemas.v1GroupKind[];
        /** NamespaceResourceWhitelist contains list of whitelisted namespace level resources */
        namespaceResourceWhitelist?: Schemas.v1GroupKind[];
        orphanedResources?: Schemas.v1alpha1OrphanedResourcesMonitorSettings;
        /** Roles are user defined RBAC roles associated with this project */
        roles?: Schemas.v1alpha1ProjectRole[];
        /** SignatureKeys contains a list of PGP key IDs that commits in Git must be signed with in order to be allowed for sync */
        signatureKeys?: Schemas.v1alpha1SignatureKey[];
        /** SourceRepos contains list of repository URLs which can be used for deployment */
        sourceRepos?: string[];
        /** SyncWindows controls when syncs can be run for apps in this project */
        syncWindows?: Schemas.v1alpha1SyncWindow[];
    }
    export interface v1alpha1AppProjectStatus {
        /** JWTTokensByRole contains a list of JWT tokens issued for a given role */
        jwtTokensByRole?: {
            [key: string]: Schemas.v1alpha1JWTTokens;
        };
    }
    export interface v1alpha1Application {
        metadata?: Schemas.v1ObjectMeta;
        operation?: Schemas.v1alpha1Operation;
        spec?: Schemas.v1alpha1ApplicationSpec;
        status?: Schemas.v1alpha1ApplicationStatus;
    }
    export interface v1alpha1ApplicationCondition {
        lastTransitionTime?: Schemas.v1Time;
        /** Message contains human-readable message indicating details about condition */
        message?: string;
        /** Type is an application condition type */
        type?: string;
    }
    export interface v1alpha1ApplicationDestination {
        /** Name is an alternate way of specifying the target cluster by its symbolic name */
        name?: string;
        /**
         * Namespace specifies the target namespace for the application's resources.
         * The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace
         */
        namespace?: string;
        /** Server specifies the URL of the target cluster and must be set to the Kubernetes control plane API */
        server?: string;
    }
    export interface v1alpha1ApplicationList {
        items?: Schemas.v1alpha1Application[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1ApplicationSource {
        /** Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo. */
        chart?: string;
        directory?: Schemas.v1alpha1ApplicationSourceDirectory;
        helm?: Schemas.v1alpha1ApplicationSourceHelm;
        ksonnet?: Schemas.v1alpha1ApplicationSourceKsonnet;
        kustomize?: Schemas.v1alpha1ApplicationSourceKustomize;
        /** Path is a directory path within the Git repository, and is only valid for applications sourced from Git. */
        path?: string;
        plugin?: Schemas.v1alpha1ApplicationSourcePlugin;
        /** RepoURL is the URL to the repository (Git or Helm) that contains the application manifests */
        repoURL?: string;
        /**
         * TargetRevision defines the revision of the source to sync the application to.
         * In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD.
         * In case of Helm, this is a semver tag for the Chart's version.
         */
        targetRevision?: string;
    }
    export interface v1alpha1ApplicationSourceDirectory {
        /** Exclude contains a glob pattern to match paths against that should be explicitly excluded from being used during manifest generation */
        exclude?: string;
        /** Include contains a glob pattern to match paths against that should be explicitly included during manifest generation */
        include?: string;
        jsonnet?: Schemas.v1alpha1ApplicationSourceJsonnet;
        /** Recurse specifies whether to scan a directory recursively for manifests */
        recurse?: boolean;
    }
    export interface v1alpha1ApplicationSourceHelm {
        /** FileParameters are file parameters to the helm template */
        fileParameters?: Schemas.v1alpha1HelmFileParameter[];
        /** Parameters is a list of Helm parameters which are passed to the helm template command upon manifest generation */
        parameters?: Schemas.v1alpha1HelmParameter[];
        /** PassCredentials pass credentials to all domains (Helm's --pass-credentials) */
        passCredentials?: boolean;
        /** ReleaseName is the Helm release name to use. If omitted it will use the application name */
        releaseName?: string;
        /** ValuesFiles is a list of Helm value files to use when generating a template */
        valueFiles?: string[];
        /** Values specifies Helm values to be passed to helm template, typically defined as a block */
        values?: string;
        /** Version is the Helm version to use for templating (either "2" or "3") */
        version?: string;
    }
    export interface v1alpha1ApplicationSourceJsonnet {
        /** ExtVars is a list of Jsonnet External Variables */
        extVars?: Schemas.v1alpha1JsonnetVar[];
        /** Additional library search dirs */
        libs?: string[];
        /** TLAS is a list of Jsonnet Top-level Arguments */
        tlas?: Schemas.v1alpha1JsonnetVar[];
    }
    export interface v1alpha1ApplicationSourceKsonnet {
        /** Environment is a ksonnet application environment name */
        environment?: string;
        /** Parameters are a list of ksonnet component parameter override values */
        parameters?: Schemas.v1alpha1KsonnetParameter[];
    }
    export interface v1alpha1ApplicationSourceKustomize {
        /** CommonAnnotations is a list of additional annotations to add to rendered manifests */
        commonAnnotations?: {
            [key: string]: string;
        };
        /** CommonLabels is a list of additional labels to add to rendered manifests */
        commonLabels?: {
            [key: string]: string;
        };
        /** ForceCommonAnnotations specifies whether to force applying common annotations to resources for Kustomize apps */
        forceCommonAnnotations?: boolean;
        /** ForceCommonLabels specifies whether to force applying common labels to resources for Kustomize apps */
        forceCommonLabels?: boolean;
        /** Images is a list of Kustomize image override specifications */
        images?: string[];
        /** NamePrefix is a prefix appended to resources for Kustomize apps */
        namePrefix?: string;
        /** NameSuffix is a suffix appended to resources for Kustomize apps */
        nameSuffix?: string;
        /** Version controls which version of Kustomize to use for rendering manifests */
        version?: string;
    }
    export interface v1alpha1ApplicationSourcePlugin {
        env?: Schemas.applicationv1alpha1EnvEntry[];
        name?: string;
    }
    /** ApplicationSpec represents desired application state. Contains link to repository with application definition and additional parameters link definition revision. */
    export interface v1alpha1ApplicationSpec {
        destination?: Schemas.v1alpha1ApplicationDestination;
        /** IgnoreDifferences is a list of resources and their fields which should be ignored during comparison */
        ignoreDifferences?: Schemas.v1alpha1ResourceIgnoreDifferences[];
        /** Info contains a list of information (URLs, email addresses, and plain text) that relates to the application */
        info?: Schemas.v1alpha1Info[];
        /**
         * Project is a reference to the project this application belongs to.
         * The empty string means that application belongs to the 'default' project.
         */
        project?: string;
        /**
         * RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions.
         * This should only be changed in exceptional circumstances.
         * Setting to zero will store no history. This will reduce storage used.
         * Increasing will increase the space used to store the history, so we do not recommend increasing it.
         * Default is 10.
         */
        revisionHistoryLimit?: string;
        source?: Schemas.v1alpha1ApplicationSource;
        syncPolicy?: Schemas.v1alpha1SyncPolicy;
    }
    export interface v1alpha1ApplicationStatus {
        /** Conditions is a list of currently observed application conditions */
        conditions?: Schemas.v1alpha1ApplicationCondition[];
        health?: Schemas.v1alpha1HealthStatus;
        /** History contains information about the application's sync history */
        history?: Schemas.v1alpha1RevisionHistory[];
        observedAt?: Schemas.v1Time;
        operationState?: Schemas.v1alpha1OperationState;
        reconciledAt?: Schemas.v1Time;
        /** Resources is a list of Kubernetes resources managed by this application */
        resources?: Schemas.v1alpha1ResourceStatus[];
        /** SourceType specifies the type of this application */
        sourceType?: string;
        summary?: Schemas.v1alpha1ApplicationSummary;
        sync?: Schemas.v1alpha1SyncStatus;
    }
    export interface v1alpha1ApplicationSummary {
        /** ExternalURLs holds all external URLs of application child resources. */
        externalURLs?: string[];
        /** Images holds all images of application child resources. */
        images?: string[];
    }
    export interface v1alpha1ApplicationTree {
        /** Hosts holds list of Kubernetes nodes that run application related pods */
        hosts?: Schemas.v1alpha1HostInfo[];
        /** Nodes contains list of nodes which either directly managed by the application and children of directly managed nodes. */
        nodes?: Schemas.v1alpha1ResourceNode[];
        /** OrphanedNodes contains if or orphaned nodes: nodes which are not managed by the app but in the same namespace. List is populated only if orphaned resources enabled in app project. */
        orphanedNodes?: Schemas.v1alpha1ResourceNode[];
    }
    /** ApplicationWatchEvent contains information about application change. */
    export interface v1alpha1ApplicationWatchEvent {
        application?: Schemas.v1alpha1Application;
        type?: string;
    }
    export interface v1alpha1Backoff {
        /** Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h") */
        duration?: string;
        /** Factor is a factor to multiply the base duration after each failed retry */
        factor?: string;
        /** MaxDuration is the maximum amount of time allowed for the backoff strategy */
        maxDuration?: string;
    }
    export interface v1alpha1Cluster {
        /** Annotations for cluster secret metadata */
        annotations?: {
            [key: string]: string;
        };
        /** Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode. */
        clusterResources?: boolean;
        config?: Schemas.v1alpha1ClusterConfig;
        connectionState?: Schemas.v1alpha1ConnectionState;
        info?: Schemas.v1alpha1ClusterInfo;
        /** Labels for cluster secret metadata */
        labels?: {
            [key: string]: string;
        };
        /** Name of the cluster. If omitted, will use the server address */
        name?: string;
        /** Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty. */
        namespaces?: string[];
        /** Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity */
        project?: string;
        refreshRequestedAt?: Schemas.v1Time;
        /** Server is the API server URL of the Kubernetes cluster */
        server?: string;
        /**
         * DEPRECATED: use Info.ServerVersion field instead.
         * The server version
         */
        serverVersion?: string;
        /** Shard contains optional shard number. Calculated on the fly by the application controller if not specified. */
        shard?: string;
    }
    export interface v1alpha1ClusterCacheInfo {
        /** APIsCount holds number of observed Kubernetes API count */
        apisCount?: string;
        lastCacheSyncTime?: Schemas.v1Time;
        /** ResourcesCount holds number of observed Kubernetes resources */
        resourcesCount?: string;
    }
    /**
     * ClusterConfig is the configuration attributes. This structure is subset of the go-client
     * rest.Config with annotations added for marshalling.
     */
    export interface v1alpha1ClusterConfig {
        awsAuthConfig?: Schemas.v1alpha1AWSAuthConfig;
        /**
         * Server requires Bearer authentication. This client will not attempt to use
         * refresh tokens for an OAuth2 flow.
         * TODO: demonstrate an OAuth2 compatible client.
         */
        bearerToken?: string;
        execProviderConfig?: Schemas.v1alpha1ExecProviderConfig;
        password?: string;
        tlsClientConfig?: Schemas.v1alpha1TLSClientConfig;
        /** Server requires Basic authentication */
        username?: string;
    }
    export interface v1alpha1ClusterInfo {
        /** APIVersions contains list of API versions supported by the cluster */
        apiVersions?: string[];
        /** ApplicationsCount is the number of applications managed by Argo CD on the cluster */
        applicationsCount?: string;
        cacheInfo?: Schemas.v1alpha1ClusterCacheInfo;
        connectionState?: Schemas.v1alpha1ConnectionState;
        /** ServerVersion contains information about the Kubernetes version of the cluster */
        serverVersion?: string;
    }
    /** ClusterList is a collection of Clusters. */
    export interface v1alpha1ClusterList {
        items?: Schemas.v1alpha1Cluster[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1Command {
        args?: string[];
        command?: string[];
    }
    export interface v1alpha1ComparedTo {
        destination?: Schemas.v1alpha1ApplicationDestination;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface v1alpha1ConfigManagementPlugin {
        generate?: Schemas.v1alpha1Command;
        init?: Schemas.v1alpha1Command;
        lockRepo?: boolean;
        name?: string;
    }
    export interface v1alpha1ConnectionState {
        attemptedAt?: Schemas.v1Time;
        /** Message contains human readable information about the connection status */
        message?: string;
        /** Status contains the current status indicator for the connection */
        status?: string;
    }
    export interface v1alpha1ExecProviderConfig {
        /** Preferred input version of the ExecInfo */
        apiVersion?: string;
        /** Arguments to pass to the command when executing it */
        args?: string[];
        /** Command to execute */
        command?: string;
        /** Env defines additional environment variables to expose to the process */
        env?: {
            [key: string]: string;
        };
        /** This text is shown to the user when the executable doesn't seem to be present */
        installHint?: string;
    }
    export interface v1alpha1GnuPGPublicKey {
        /** Fingerprint is the fingerprint of the key */
        fingerprint?: string;
        /** KeyData holds the raw key data, in base64 encoded format */
        keyData?: string;
        /** KeyID specifies the key ID, in hexadecimal string format */
        keyID?: string;
        /** Owner holds the owner identification, e.g. a name and e-mail address */
        owner?: string;
        /** SubType holds the key's sub type (e.g. rsa4096) */
        subType?: string;
        /** Trust holds the level of trust assigned to this key */
        trust?: string;
    }
    export interface v1alpha1GnuPGPublicKeyList {
        items?: Schemas.v1alpha1GnuPGPublicKey[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1HealthStatus {
        /** Message is a human-readable informational message describing the health status */
        message?: string;
        /** Status holds the status code of the application or resource */
        status?: string;
    }
    export interface v1alpha1HelmFileParameter {
        /** Name is the name of the Helm parameter */
        name?: string;
        /** Path is the path to the file containing the values for the Helm parameter */
        path?: string;
    }
    export interface v1alpha1HelmParameter {
        /** ForceString determines whether to tell Helm to interpret booleans and numbers as strings */
        forceString?: boolean;
        /** Name is the name of the Helm parameter */
        name?: string;
        /** Value is the value for the Helm parameter */
        value?: string;
    }
    export interface v1alpha1HostInfo {
        name?: string;
        resourcesInfo?: Schemas.v1alpha1HostResourceInfo[];
        systemInfo?: Schemas.v1NodeSystemInfo;
    }
    export interface v1alpha1HostResourceInfo {
        capacity?: string;
        requestedByApp?: string;
        requestedByNeighbors?: string;
        resourceName?: string;
    }
    export interface v1alpha1Info {
        name?: string;
        value?: string;
    }
    export interface v1alpha1InfoItem {
        /** Name is a human readable title for this piece of information. */
        name?: string;
        /** Value is human readable content. */
        value?: string;
    }
    export interface v1alpha1JWTToken {
        exp?: string;
        iat?: string;
        id?: string;
    }
    export interface v1alpha1JWTTokens {
        items?: Schemas.v1alpha1JWTToken[];
    }
    export interface v1alpha1JsonnetVar {
        code?: boolean;
        name?: string;
        value?: string;
    }
    export interface v1alpha1KnownTypeField {
        field?: string;
        type?: string;
    }
    export interface v1alpha1KsonnetParameter {
        component?: string;
        name?: string;
        value?: string;
    }
    export interface v1alpha1KustomizeOptions {
        /** BinaryPath holds optional path to kustomize binary */
        binaryPath?: string;
        /** BuildOptions is a string of build parameters to use when calling `kustomize build` */
        buildOptions?: string;
    }
    export interface v1alpha1Operation {
        /** Info is a list of informational items for this operation */
        info?: Schemas.v1alpha1Info[];
        initiatedBy?: Schemas.v1alpha1OperationInitiator;
        retry?: Schemas.v1alpha1RetryStrategy;
        sync?: Schemas.v1alpha1SyncOperation;
    }
    export interface v1alpha1OperationInitiator {
        /** Automated is set to true if operation was initiated automatically by the application controller. */
        automated?: boolean;
        /** Username contains the name of a user who started operation */
        username?: string;
    }
    export interface v1alpha1OperationState {
        finishedAt?: Schemas.v1Time;
        /** Message holds any pertinent messages when attempting to perform operation (typically errors). */
        message?: string;
        operation?: Schemas.v1alpha1Operation;
        /** Phase is the current phase of the operation */
        phase?: string;
        /** RetryCount contains time of operation retries */
        retryCount?: string;
        startedAt?: Schemas.v1Time;
        syncResult?: Schemas.v1alpha1SyncOperationResult;
    }
    export interface v1alpha1OrphanedResourceKey {
        group?: string;
        kind?: string;
        name?: string;
    }
    export interface v1alpha1OrphanedResourcesMonitorSettings {
        /** Ignore contains a list of resources that are to be excluded from orphaned resources monitoring */
        ignore?: Schemas.v1alpha1OrphanedResourceKey[];
        /** Warn indicates if warning condition should be created for apps which have orphaned resources */
        warn?: boolean;
    }
    export interface v1alpha1OverrideIgnoreDiff {
        jSONPointers?: string[];
        jqPathExpressions?: string[];
    }
    export interface v1alpha1ProjectRole {
        /** Description is a description of the role */
        description?: string;
        /** Groups are a list of OIDC group claims bound to this role */
        groups?: string[];
        /** JWTTokens are a list of generated JWT tokens bound to this role */
        jwtTokens?: Schemas.v1alpha1JWTToken[];
        /** Name is a name for this role */
        name?: string;
        /** Policies Stores a list of casbin formatted strings that define access policies for the role in the project */
        policies?: string[];
    }
    export interface v1alpha1RepoCreds {
        /** EnableOCI specifies whether helm-oci support should be enabled for this repo */
        enableOCI?: boolean;
        /** GithubAppEnterpriseBaseURL specifies the GitHub API URL for GitHub app authentication. If empty will default to https://api.github.com */
        githubAppEnterpriseBaseUrl?: string;
        /** GithubAppId specifies the Github App ID of the app used to access the repo for GitHub app authentication */
        githubAppID?: string;
        /** GithubAppInstallationId specifies the ID of the installed GitHub App for GitHub app authentication */
        githubAppInstallationID?: string;
        /** GithubAppPrivateKey specifies the private key PEM data for authentication via GitHub app */
        githubAppPrivateKey?: string;
        /** Password for authenticating at the repo server */
        password?: string;
        /** SSHPrivateKey contains the private key data for authenticating at the repo server using SSH (only Git repos) */
        sshPrivateKey?: string;
        /** TLSClientCertData specifies the TLS client cert data for authenticating at the repo server */
        tlsClientCertData?: string;
        /** TLSClientCertKey specifies the TLS client cert key for authenticating at the repo server */
        tlsClientCertKey?: string;
        /** Type specifies the type of the repoCreds. Can be either "git" or "helm. "git" is assumed if empty or absent. */
        type?: string;
        /** URL is the URL that this credentials matches to */
        url?: string;
        /** Username for authenticating at the repo server */
        username?: string;
    }
    /** RepositoryList is a collection of Repositories. */
    export interface v1alpha1RepoCredsList {
        items?: Schemas.v1alpha1RepoCreds[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1Repository {
        connectionState?: Schemas.v1alpha1ConnectionState;
        /** EnableLFS specifies whether git-lfs support should be enabled for this repo. Only valid for Git repositories. */
        enableLfs?: boolean;
        /** EnableOCI specifies whether helm-oci support should be enabled for this repo */
        enableOCI?: boolean;
        /** GithubAppEnterpriseBaseURL specifies the base URL of GitHub Enterprise installation. If empty will default to https://api.github.com */
        githubAppEnterpriseBaseUrl?: string;
        /** GithubAppId specifies the ID of the GitHub app used to access the repo */
        githubAppID?: string;
        /** GithubAppInstallationId specifies the installation ID of the GitHub App used to access the repo */
        githubAppInstallationID?: string;
        /** Github App Private Key PEM data */
        githubAppPrivateKey?: string;
        /** Whether credentials were inherited from a credential set */
        inheritedCreds?: boolean;
        /** Insecure specifies whether the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys */
        insecure?: boolean;
        /**
         * InsecureIgnoreHostKey should not be used anymore, Insecure is favoured
         * Used only for Git repos
         */
        insecureIgnoreHostKey?: boolean;
        /** Name specifies a name to be used for this repo. Only used with Helm repos */
        name?: string;
        /** Password contains the password or PAT used for authenticating at the remote repository */
        password?: string;
        /** Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity */
        project?: string;
        /** Proxy specifies the HTTP/HTTPS proxy used to access the repo */
        proxy?: string;
        /** Repo contains the URL to the remote repository */
        repo?: string;
        /** SSHPrivateKey contains the PEM data for authenticating at the repo server. Only used with Git repos. */
        sshPrivateKey?: string;
        /** TLSClientCertData contains a certificate in PEM format for authenticating at the repo server */
        tlsClientCertData?: string;
        /** TLSClientCertKey contains a private key in PEM format for authenticating at the repo server */
        tlsClientCertKey?: string;
        /** Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent. */
        type?: string;
        /** Username contains the user name used for authenticating at the remote repository */
        username?: string;
    }
    export interface v1alpha1RepositoryCertificate {
        /** CertData contains the actual certificate data, dependent on the certificate type */
        certData?: Blob;
        /** CertInfo will hold additional certificate info, depdendent on the certificate type (e.g. SSH fingerprint, X509 CommonName) */
        certInfo?: string;
        /** CertSubType specifies the sub type of the cert, i.e. "ssh-rsa" */
        certSubType?: string;
        /** CertType specifies the type of the certificate - currently one of "https" or "ssh" */
        certType?: string;
        /** ServerName specifies the DNS name of the server this certificate is intended for */
        serverName?: string;
    }
    export interface v1alpha1RepositoryCertificateList {
        /** List of certificates to be processed */
        items?: Schemas.v1alpha1RepositoryCertificate[];
        metadata?: Schemas.v1ListMeta;
    }
    /** RepositoryList is a collection of Repositories. */
    export interface v1alpha1RepositoryList {
        items?: Schemas.v1alpha1Repository[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1ResourceAction {
        disabled?: boolean;
        name?: string;
        params?: Schemas.v1alpha1ResourceActionParam[];
    }
    export interface v1alpha1ResourceActionParam {
        default?: string;
        name?: string;
        type?: string;
        value?: string;
    }
    export interface v1alpha1ResourceDiff {
        /**
         * Diff contains the JSON patch between target and live resource
         * Deprecated: use NormalizedLiveState and PredictedLiveState to render the difference
         */
        diff?: string;
        group?: string;
        hook?: boolean;
        kind?: string;
        /** TargetState contains the JSON live resource manifest */
        liveState?: string;
        modified?: boolean;
        name?: string;
        namespace?: string;
        /** NormalizedLiveState contains JSON serialized live resource state with applied normalizations */
        normalizedLiveState?: string;
        /** PredictedLiveState contains JSON serialized resource state that is calculated based on normalized and target resource state */
        predictedLiveState?: string;
        resourceVersion?: string;
        /** TargetState contains the JSON serialized resource manifest defined in the Git/Helm */
        targetState?: string;
    }
    /** ResourceIgnoreDifferences contains resource filter and list of json paths which should be ignored during comparison with live state. */
    export interface v1alpha1ResourceIgnoreDifferences {
        group?: string;
        jqPathExpressions?: string[];
        jsonPointers?: string[];
        kind?: string;
        name?: string;
        namespace?: string;
    }
    export interface v1alpha1ResourceNetworkingInfo {
        /** ExternalURLs holds list of URLs which should be available externally. List is populated for ingress resources using rules hostnames. */
        externalURLs?: string[];
        ingress?: Schemas.v1LoadBalancerIngress[];
        labels?: {
            [key: string]: string;
        };
        targetLabels?: {
            [key: string]: string;
        };
        targetRefs?: Schemas.v1alpha1ResourceRef[];
    }
    export interface v1alpha1ResourceNode {
        createdAt?: Schemas.v1Time;
        health?: Schemas.v1alpha1HealthStatus;
        images?: string[];
        info?: Schemas.v1alpha1InfoItem[];
        networkingInfo?: Schemas.v1alpha1ResourceNetworkingInfo;
        parentRefs?: Schemas.v1alpha1ResourceRef[];
        resourceRef?: Schemas.v1alpha1ResourceRef;
        resourceVersion?: string;
    }
    export interface v1alpha1ResourceOverride {
        actions?: string;
        healthLua?: string;
        ignoreDifferences?: Schemas.v1alpha1OverrideIgnoreDiff;
        knownTypeFields?: Schemas.v1alpha1KnownTypeField[];
        useOpenLibs?: boolean;
    }
    export interface v1alpha1ResourceRef {
        group?: string;
        kind?: string;
        name?: string;
        namespace?: string;
        uid?: string;
        version?: string;
    }
    export interface v1alpha1ResourceResult {
        /** Group specifies the API group of the resource */
        group?: string;
        /**
         * HookPhase contains the state of any operation associated with this resource OR hook
         * This can also contain values for non-hook resources.
         */
        hookPhase?: string;
        /** HookType specifies the type of the hook. Empty for non-hook resources */
        hookType?: string;
        /** Kind specifies the API kind of the resource */
        kind?: string;
        /** Message contains an informational or error message for the last sync OR operation */
        message?: string;
        /** Name specifies the name of the resource */
        name?: string;
        /** Namespace specifies the target namespace of the resource */
        namespace?: string;
        /** Status holds the final result of the sync. Will be empty if the resources is yet to be applied/pruned and is always zero-value for hooks */
        status?: string;
        /** SyncPhase indicates the particular phase of the sync that this result was acquired in */
        syncPhase?: string;
        /** Version specifies the API version of the resource */
        version?: string;
    }
    export interface v1alpha1ResourceStatus {
        group?: string;
        health?: Schemas.v1alpha1HealthStatus;
        hook?: boolean;
        kind?: string;
        name?: string;
        namespace?: string;
        requiresPruning?: boolean;
        status?: string;
        version?: string;
    }
    export interface v1alpha1RetryStrategy {
        backoff?: Schemas.v1alpha1Backoff;
        /** Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed. */
        limit?: string;
    }
    export interface v1alpha1RevisionHistory {
        deployStartedAt?: Schemas.v1Time;
        deployedAt?: Schemas.v1Time;
        /** ID is an auto incrementing identifier of the RevisionHistory */
        id?: string;
        /** Revision holds the revision the sync was performed against */
        revision?: string;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface v1alpha1RevisionMetadata {
        /**
         * who authored this revision,
         * typically their name and email, e.g. "John Doe <john_doe@my-company.com>",
         * but might not match this example
         */
        author?: string;
        date?: Schemas.v1Time;
        /**
         * Message contains the message associated with the revision, most likely the commit message.
         * The message is truncated to the first newline or 64 characters (which ever comes first)
         */
        message?: string;
        /** SignatureInfo contains a hint on the signer if the revision was signed with GPG, and signature verification is enabled. */
        signatureInfo?: string;
        /**
         * Tags specifies any tags currently attached to the revision
         * Floating tags can move from one revision to another
         */
        tags?: string[];
    }
    export interface v1alpha1SignatureKey {
        /** The ID of the key in hexadecimal notation */
        keyID?: string;
    }
    /** SyncOperation contains details about a sync operation. */
    export interface v1alpha1SyncOperation {
        /** DryRun specifies to perform a `kubectl apply --dry-run` without actually performing the sync */
        dryRun?: boolean;
        /** Manifests is an optional field that overrides sync source with a local directory for development */
        manifests?: string[];
        /** Prune specifies to delete resources from the cluster that are no longer tracked in git */
        prune?: boolean;
        /** Resources describes which resources shall be part of the sync */
        resources?: Schemas.v1alpha1SyncOperationResource[];
        /**
         * Revision is the revision (Git) or chart version (Helm) which to sync the application to
         * If omitted, will use the revision specified in app spec.
         */
        revision?: string;
        source?: Schemas.v1alpha1ApplicationSource;
        /** SyncOptions provide per-sync sync-options, e.g. Validate=false */
        syncOptions?: string[];
        syncStrategy?: Schemas.v1alpha1SyncStrategy;
    }
    /** SyncOperationResource contains resources to sync. */
    export interface v1alpha1SyncOperationResource {
        group?: string;
        kind?: string;
        name?: string;
        namespace?: string;
    }
    export interface v1alpha1SyncOperationResult {
        /** Resources contains a list of sync result items for each individual resource in a sync operation */
        resources?: Schemas.v1alpha1ResourceResult[];
        /** Revision holds the revision this sync operation was performed to */
        revision?: string;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface v1alpha1SyncPolicy {
        automated?: Schemas.v1alpha1SyncPolicyAutomated;
        retry?: Schemas.v1alpha1RetryStrategy;
        /** Options allow you to specify whole app sync-options */
        syncOptions?: string[];
    }
    export interface v1alpha1SyncPolicyAutomated {
        /** AllowEmpty allows apps have zero live resources (default: false) */
        allowEmpty?: boolean;
        /** Prune specifies whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false) */
        prune?: boolean;
        /** SelfHeal specifes whether to revert resources back to their desired state upon modification in the cluster (default: false) */
        selfHeal?: boolean;
    }
    export interface v1alpha1SyncStatus {
        comparedTo?: Schemas.v1alpha1ComparedTo;
        /** Revision contains information about the revision the comparison has been performed to */
        revision?: string;
        /** Status is the sync state of the comparison */
        status?: string;
    }
    export interface v1alpha1SyncStrategy {
        apply?: Schemas.v1alpha1SyncStrategyApply;
        hook?: Schemas.v1alpha1SyncStrategyHook;
    }
    export interface v1alpha1SyncStrategyApply {
        /**
         * Force indicates whether or not to supply the --force flag to `kubectl apply`.
         * The --force flag deletes and re-create the resource, when PATCH encounters conflict and has
         * retried for 5 times.
         */
        force?: boolean;
    }
    /**
     * SyncStrategyHook will perform a sync using hooks annotations.
     * If no hook annotation is specified falls back to `kubectl apply`.
     */
    export interface v1alpha1SyncStrategyHook {
        syncStrategyApply?: Schemas.v1alpha1SyncStrategyApply;
    }
    export interface v1alpha1SyncWindow {
        /** Applications contains a list of applications that the window will apply to */
        applications?: string[];
        /** Clusters contains a list of clusters that the window will apply to */
        clusters?: string[];
        /** Duration is the amount of time the sync window will be open */
        duration?: string;
        /** Kind defines if the window allows or blocks syncs */
        kind?: string;
        /** ManualSync enables manual syncs when they would otherwise be blocked */
        manualSync?: boolean;
        /** Namespaces contains a list of namespaces that the window will apply to */
        namespaces?: string[];
        /** Schedule is the time the window will begin, specified in cron format */
        schedule?: string;
        /** TimeZone of the sync that will be applied to the schedule */
        timeZone?: string;
    }
    export interface v1alpha1TLSClientConfig {
        /**
         * CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
         * CAData takes precedence over CAFile
         */
        caData?: Blob;
        /**
         * CertData holds PEM-encoded bytes (typically read from a client certificate file).
         * CertData takes precedence over CertFile
         */
        certData?: Blob;
        /** Insecure specifies that the server should be accessed without verifying the TLS certificate. For testing only. */
        insecure?: boolean;
        /**
         * KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
         * KeyData takes precedence over KeyFile
         */
        keyData?: Blob;
        /**
         * ServerName is passed to the server for SNI and is used in the client to check server
         * certificates against. If ServerName is empty, the hostname used to contact the
         * server is used.
         */
        serverName?: string;
    }
    export interface versionVersionMessage {
        BuildDate?: string;
        Compiler?: string;
        GitCommit?: string;
        GitTag?: string;
        GitTreeState?: string;
        GoVersion?: string;
        HelmVersion?: string;
        JsonnetVersion?: string;
        KsonnetVersion?: string;
        KubectlVersion?: string;
        KustomizeVersion?: string;
        Platform?: string;
        Version?: string;
    }
}
export namespace RequestBodies {
    export namespace v1alpha1Application {
        export interface Content {
            "application/json": Schemas.v1alpha1Application;
        }
    }
    export namespace ApplicationService_PatchResourceBody {
        export interface Content {
            "application/json": string;
        }
    }
    export namespace v1alpha1Cluster {
        export interface Content {
            "application/json": Schemas.v1alpha1Cluster;
        }
    }
}
export interface Response$AccountService_ListAccounts$Status$200 {
    "application/json": Schemas.accountAccountsList;
}
export interface Response$AccountService_ListAccounts$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$AccountService_CanI {
    resource: string;
    action: string;
    subresource: string;
}
export interface Response$AccountService_CanI$Status$200 {
    "application/json": Schemas.accountCanIResponse;
}
export interface Response$AccountService_CanI$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface RequestBody$AccountService_UpdatePassword {
    "application/json": Schemas.accountUpdatePasswordRequest;
}
export interface Response$AccountService_UpdatePassword$Status$200 {
    "application/json": Schemas.accountUpdatePasswordResponse;
}
export interface Response$AccountService_UpdatePassword$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$AccountService_GetAccount {
    name: string;
}
export interface Response$AccountService_GetAccount$Status$200 {
    "application/json": Schemas.accountAccount;
}
export interface Response$AccountService_GetAccount$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$AccountService_CreateToken {
    name: string;
}
export interface RequestBody$AccountService_CreateToken {
    "application/json": Schemas.accountCreateTokenRequest;
}
export interface Response$AccountService_CreateToken$Status$200 {
    "application/json": Schemas.accountCreateTokenResponse;
}
export interface Response$AccountService_CreateToken$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$AccountService_DeleteToken {
    name: string;
    id: string;
}
export interface Response$AccountService_DeleteToken$Status$200 {
    "application/json": Schemas.accountEmptyResponse;
}
export interface Response$AccountService_DeleteToken$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_List {
    /** the application's name. */
    name?: string;
    /** forces application reconciliation if set to true. */
    refresh?: string;
    /** the project names to restrict returned list applications. */
    project?: string[];
    /** when specified with a watch call, shows changes that occur after that particular version of a resource. */
    resourceVersion?: string;
    /** the selector to to restrict returned list to applications only with matched labels. */
    selector?: string;
    /** the repoURL to restrict returned list applications. */
    repo?: string;
}
export interface Response$ApplicationService_List$Status$200 {
    "application/json": Schemas.v1alpha1ApplicationList;
}
export interface Response$ApplicationService_List$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Create {
    upsert?: boolean;
    validate?: boolean;
}
export type RequestBody$ApplicationService_Create = RequestBodies.v1alpha1Application.Content;
export interface Response$ApplicationService_Create$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Response$ApplicationService_Create$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Update {
    /**
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: http://kubernetes.io/docs/user-guide/identifiers#names
     * +optional
     */
    "application.metadata.name": string;
    validate?: boolean;
}
export type RequestBody$ApplicationService_Update = RequestBodies.v1alpha1Application.Content;
export interface Response$ApplicationService_Update$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Response$ApplicationService_Update$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_ManagedResources {
    applicationName: string;
    namespace?: string;
    name?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ApplicationService_ManagedResources$Status$200 {
    "application/json": Schemas.applicationManagedResourcesResponse;
}
export interface Response$ApplicationService_ManagedResources$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_ResourceTree {
    applicationName: string;
    namespace?: string;
    name?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ApplicationService_ResourceTree$Status$200 {
    "application/json": Schemas.v1alpha1ApplicationTree;
}
export interface Response$ApplicationService_ResourceTree$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Get {
    /** the application's name */
    name: string;
    /** forces application reconciliation if set to true. */
    refresh?: string;
    /** the project names to restrict returned list applications. */
    project?: string[];
    /** when specified with a watch call, shows changes that occur after that particular version of a resource. */
    resourceVersion?: string;
    /** the selector to to restrict returned list to applications only with matched labels. */
    selector?: string;
    /** the repoURL to restrict returned list applications. */
    repo?: string;
}
export interface Response$ApplicationService_Get$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Response$ApplicationService_Get$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Delete {
    name: string;
    cascade?: boolean;
    propagationPolicy?: string;
}
export interface Response$ApplicationService_Delete$Status$200 {
    "application/json": Schemas.applicationApplicationResponse;
}
export interface Response$ApplicationService_Delete$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Patch {
    name: string;
}
export interface RequestBody$ApplicationService_Patch {
    "application/json": Schemas.applicationApplicationPatchRequest;
}
export interface Response$ApplicationService_Patch$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Response$ApplicationService_Patch$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_ListResourceEvents {
    name: string;
    resourceNamespace?: string;
    resourceName?: string;
    resourceUID?: string;
}
export interface Response$ApplicationService_ListResourceEvents$Status$200 {
    "application/json": Schemas.v1EventList;
}
export interface Response$ApplicationService_ListResourceEvents$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_PodLogs2 {
    name: string;
    namespace?: string;
    podName?: string;
    container?: string;
    sinceSeconds?: string;
    /**
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     */
    "sinceTime.seconds"?: string;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     */
    "sinceTime.nanos"?: number;
    tailLines?: string;
    follow?: boolean;
    untilTime?: string;
    filter?: string;
    kind?: string;
    group?: string;
    resourceName?: string;
    previous?: boolean;
}
export interface Response$ApplicationService_PodLogs2$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.applicationLogEntry;
    };
}
export interface Response$ApplicationService_PodLogs2$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_GetManifests {
    name: string;
    revision?: string;
}
export interface Response$ApplicationService_GetManifests$Status$200 {
    "application/json": Schemas.repositoryManifestResponse;
}
export interface Response$ApplicationService_GetManifests$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_TerminateOperation {
    name: string;
}
export interface Response$ApplicationService_TerminateOperation$Status$200 {
    "application/json": Schemas.applicationOperationTerminateResponse;
}
export interface Response$ApplicationService_TerminateOperation$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_PodLogs {
    name: string;
    podName: string;
    namespace?: string;
    container?: string;
    sinceSeconds?: string;
    /**
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     */
    "sinceTime.seconds"?: string;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     */
    "sinceTime.nanos"?: number;
    tailLines?: string;
    follow?: boolean;
    untilTime?: string;
    filter?: string;
    kind?: string;
    group?: string;
    resourceName?: string;
    previous?: boolean;
}
export interface Response$ApplicationService_PodLogs$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.applicationLogEntry;
    };
}
export interface Response$ApplicationService_PodLogs$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_GetResource {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ApplicationService_GetResource$Status$200 {
    "application/json": Schemas.applicationApplicationResourceResponse;
}
export interface Response$ApplicationService_GetResource$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_PatchResource {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
    patchType?: string;
}
export type RequestBody$ApplicationService_PatchResource = RequestBodies.ApplicationService_PatchResourceBody.Content;
export interface Response$ApplicationService_PatchResource$Status$200 {
    "application/json": Schemas.applicationApplicationResourceResponse;
}
export interface Response$ApplicationService_PatchResource$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_DeleteResource {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
    force?: boolean;
    orphan?: boolean;
}
export interface Response$ApplicationService_DeleteResource$Status$200 {
    "application/json": Schemas.applicationApplicationResponse;
}
export interface Response$ApplicationService_DeleteResource$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_ListResourceActions {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ApplicationService_ListResourceActions$Status$200 {
    "application/json": Schemas.applicationResourceActionsListResponse;
}
export interface Response$ApplicationService_ListResourceActions$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_RunResourceAction {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export type RequestBody$ApplicationService_RunResourceAction = RequestBodies.ApplicationService_PatchResourceBody.Content;
export interface Response$ApplicationService_RunResourceAction$Status$200 {
    "application/json": Schemas.applicationApplicationResponse;
}
export interface Response$ApplicationService_RunResourceAction$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_RevisionMetadata {
    /** the application's name */
    name: string;
    /** the revision of the app */
    revision: string;
}
export interface Response$ApplicationService_RevisionMetadata$Status$200 {
    "application/json": Schemas.v1alpha1RevisionMetadata;
}
export interface Response$ApplicationService_RevisionMetadata$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Rollback {
    name: string;
}
export interface RequestBody$ApplicationService_Rollback {
    "application/json": Schemas.applicationApplicationRollbackRequest;
}
export interface Response$ApplicationService_Rollback$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Response$ApplicationService_Rollback$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_UpdateSpec {
    name: string;
    validate?: boolean;
}
export interface RequestBody$ApplicationService_UpdateSpec {
    "application/json": Schemas.v1alpha1ApplicationSpec;
}
export interface Response$ApplicationService_UpdateSpec$Status$200 {
    "application/json": Schemas.v1alpha1ApplicationSpec;
}
export interface Response$ApplicationService_UpdateSpec$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Sync {
    name: string;
}
export interface RequestBody$ApplicationService_Sync {
    "application/json": Schemas.applicationApplicationSyncRequest;
}
export interface Response$ApplicationService_Sync$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Response$ApplicationService_Sync$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_GetApplicationSyncWindows {
    name: string;
}
export interface Response$ApplicationService_GetApplicationSyncWindows$Status$200 {
    "application/json": Schemas.applicationApplicationSyncWindowsResponse;
}
export interface Response$ApplicationService_GetApplicationSyncWindows$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$CertificateService_ListCertificates {
    /** A file-glob pattern (not regular expression) the host name has to match. */
    hostNamePattern?: string;
    /** The type of the certificate to match (ssh or https). */
    certType?: string;
    /** The sub type of the certificate to match (protocol dependent, usually only used for ssh certs). */
    certSubType?: string;
}
export interface Response$CertificateService_ListCertificates$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Response$CertificateService_ListCertificates$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$CertificateService_CreateCertificate {
    /** Whether to upsert already existing certificates. */
    upsert?: boolean;
}
export interface RequestBody$CertificateService_CreateCertificate {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Response$CertificateService_CreateCertificate$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Response$CertificateService_CreateCertificate$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$CertificateService_DeleteCertificate {
    /** A file-glob pattern (not regular expression) the host name has to match. */
    hostNamePattern?: string;
    /** The type of the certificate to match (ssh or https). */
    certType?: string;
    /** The sub type of the certificate to match (protocol dependent, usually only used for ssh certs). */
    certSubType?: string;
}
export interface Response$CertificateService_DeleteCertificate$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Response$CertificateService_DeleteCertificate$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_List {
    server?: string;
    name?: string;
}
export interface Response$ClusterService_List$Status$200 {
    "application/json": Schemas.v1alpha1ClusterList;
}
export interface Response$ClusterService_List$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_Create {
    upsert?: boolean;
}
export type RequestBody$ClusterService_Create = RequestBodies.v1alpha1Cluster.Content;
export interface Response$ClusterService_Create$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Response$ClusterService_Create$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_Update {
    /** Server is the API server URL of the Kubernetes cluster */
    "cluster.server": string;
    updatedFields?: string[];
}
export type RequestBody$ClusterService_Update = RequestBodies.v1alpha1Cluster.Content;
export interface Response$ClusterService_Update$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Response$ClusterService_Update$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_Get {
    server: string;
    name?: string;
}
export interface Response$ClusterService_Get$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Response$ClusterService_Get$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_Delete {
    server: string;
    name?: string;
}
export interface Response$ClusterService_Delete$Status$200 {
    "application/json": Schemas.clusterClusterResponse;
}
export interface Response$ClusterService_Delete$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_InvalidateCache {
    server: string;
}
export interface Response$ClusterService_InvalidateCache$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Response$ClusterService_InvalidateCache$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ClusterService_RotateAuth {
    server: string;
}
export interface Response$ClusterService_RotateAuth$Status$200 {
    "application/json": Schemas.clusterClusterResponse;
}
export interface Response$ClusterService_RotateAuth$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$GPGKeyService_List {
    /** The GPG key ID to query for. */
    keyID?: string;
}
export interface Response$GPGKeyService_List$Status$200 {
    "application/json": Schemas.v1alpha1GnuPGPublicKeyList;
}
export interface Response$GPGKeyService_List$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$GPGKeyService_Create {
    /** Whether to upsert already existing public keys. */
    upsert?: boolean;
}
export interface RequestBody$GPGKeyService_Create {
    "application/json": Schemas.v1alpha1GnuPGPublicKey;
}
export interface Response$GPGKeyService_Create$Status$200 {
    "application/json": Schemas.gpgkeyGnuPGPublicKeyCreateResponse;
}
export interface Response$GPGKeyService_Create$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$GPGKeyService_Delete {
    /** The GPG key ID to query for. */
    keyID?: string;
}
export interface Response$GPGKeyService_Delete$Status$200 {
    "application/json": Schemas.gpgkeyGnuPGPublicKeyResponse;
}
export interface Response$GPGKeyService_Delete$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$GPGKeyService_Get {
    /** The GPG key ID to query for */
    keyID: string;
}
export interface Response$GPGKeyService_Get$Status$200 {
    "application/json": Schemas.v1alpha1GnuPGPublicKey;
}
export interface Response$GPGKeyService_Get$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_List {
    name?: string;
}
export interface Response$ProjectService_List$Status$200 {
    "application/json": Schemas.v1alpha1AppProjectList;
}
export interface Response$ProjectService_List$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface RequestBody$ProjectService_Create {
    "application/json": Schemas.projectProjectCreateRequest;
}
export interface Response$ProjectService_Create$Status$200 {
    "application/json": Schemas.v1alpha1AppProject;
}
export interface Response$ProjectService_Create$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_Get {
    name: string;
}
export interface Response$ProjectService_Get$Status$200 {
    "application/json": Schemas.v1alpha1AppProject;
}
export interface Response$ProjectService_Get$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_Delete {
    name: string;
}
export interface Response$ProjectService_Delete$Status$200 {
    "application/json": Schemas.projectEmptyResponse;
}
export interface Response$ProjectService_Delete$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_GetDetailedProject {
    name: string;
}
export interface Response$ProjectService_GetDetailedProject$Status$200 {
    "application/json": Schemas.projectDetailedProjectsResponse;
}
export interface Response$ProjectService_GetDetailedProject$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_ListEvents {
    name: string;
}
export interface Response$ProjectService_ListEvents$Status$200 {
    "application/json": Schemas.v1EventList;
}
export interface Response$ProjectService_ListEvents$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_GetGlobalProjects {
    name: string;
}
export interface Response$ProjectService_GetGlobalProjects$Status$200 {
    "application/json": Schemas.projectGlobalProjectsResponse;
}
export interface Response$ProjectService_GetGlobalProjects$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_GetSyncWindowsState {
    name: string;
}
export interface Response$ProjectService_GetSyncWindowsState$Status$200 {
    "application/json": Schemas.projectSyncWindowsResponse;
}
export interface Response$ProjectService_GetSyncWindowsState$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_Update {
    /**
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: http://kubernetes.io/docs/user-guide/identifiers#names
     * +optional
     */
    "project.metadata.name": string;
}
export interface RequestBody$ProjectService_Update {
    "application/json": Schemas.projectProjectUpdateRequest;
}
export interface Response$ProjectService_Update$Status$200 {
    "application/json": Schemas.v1alpha1AppProject;
}
export interface Response$ProjectService_Update$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_CreateToken {
    project: string;
    role: string;
}
export interface RequestBody$ProjectService_CreateToken {
    "application/json": Schemas.projectProjectTokenCreateRequest;
}
export interface Response$ProjectService_CreateToken$Status$200 {
    "application/json": Schemas.projectProjectTokenResponse;
}
export interface Response$ProjectService_CreateToken$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ProjectService_DeleteToken {
    project: string;
    role: string;
    iat: string;
    id?: string;
}
export interface Response$ProjectService_DeleteToken$Status$200 {
    "application/json": Schemas.projectEmptyResponse;
}
export interface Response$ProjectService_DeleteToken$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepoCredsService_ListRepositoryCredentials {
    /** Repo URL for query. */
    url?: string;
}
export interface Response$RepoCredsService_ListRepositoryCredentials$Status$200 {
    "application/json": Schemas.v1alpha1RepoCredsList;
}
export interface Response$RepoCredsService_ListRepositoryCredentials$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepoCredsService_CreateRepositoryCredentials {
    /** Whether to create in upsert mode. */
    upsert?: boolean;
}
export interface RequestBody$RepoCredsService_CreateRepositoryCredentials {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Response$RepoCredsService_CreateRepositoryCredentials$Status$200 {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Response$RepoCredsService_CreateRepositoryCredentials$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepoCredsService_UpdateRepositoryCredentials {
    /** URL is the URL that this credentials matches to */
    "creds.url": string;
}
export interface RequestBody$RepoCredsService_UpdateRepositoryCredentials {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Response$RepoCredsService_UpdateRepositoryCredentials$Status$200 {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Response$RepoCredsService_UpdateRepositoryCredentials$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepoCredsService_DeleteRepositoryCredentials {
    url: string;
}
export interface Response$RepoCredsService_DeleteRepositoryCredentials$Status$200 {
    "application/json": Schemas.repocredsRepoCredsResponse;
}
export interface Response$RepoCredsService_DeleteRepositoryCredentials$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_ListRepositories {
    /** Repo URL for query. */
    repo?: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$RepositoryService_ListRepositories$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryList;
}
export interface Response$RepositoryService_ListRepositories$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_CreateRepository {
    /** Whether to create in upsert mode. */
    upsert?: boolean;
    /** Whether to operate on credential set instead of repository. */
    credsOnly?: boolean;
}
export interface RequestBody$RepositoryService_CreateRepository {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$RepositoryService_CreateRepository$Status$200 {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$RepositoryService_CreateRepository$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_UpdateRepository {
    /** Repo contains the URL to the remote repository */
    "repo.repo": string;
}
export interface RequestBody$RepositoryService_UpdateRepository {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$RepositoryService_UpdateRepository$Status$200 {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$RepositoryService_UpdateRepository$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_Get {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$RepositoryService_Get$Status$200 {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$RepositoryService_Get$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_DeleteRepository {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$RepositoryService_DeleteRepository$Status$200 {
    "application/json": Schemas.repositoryRepoResponse;
}
export interface Response$RepositoryService_DeleteRepository$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_ListApps {
    repo: string;
    revision?: string;
}
export interface Response$RepositoryService_ListApps$Status$200 {
    "application/json": Schemas.repositoryRepoAppsResponse;
}
export interface Response$RepositoryService_ListApps$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_GetHelmCharts {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$RepositoryService_GetHelmCharts$Status$200 {
    "application/json": Schemas.repositoryHelmChartsResponse;
}
export interface Response$RepositoryService_GetHelmCharts$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_ListRefs {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$RepositoryService_ListRefs$Status$200 {
    "application/json": Schemas.repositoryRefs;
}
export interface Response$RepositoryService_ListRefs$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_ValidateAccess {
    /** The URL to the repo */
    repo: string;
    /** Username for accessing repo. */
    username?: string;
    /** Password for accessing repo. */
    password?: string;
    /** Private key data for accessing SSH repository. */
    sshPrivateKey?: string;
    /** Whether to skip certificate or host key validation. */
    insecure?: boolean;
    /** TLS client cert data for accessing HTTPS repository. */
    tlsClientCertData?: string;
    /** TLS client cert key for accessing HTTPS repository. */
    tlsClientCertKey?: string;
    /** The type of the repo. */
    type?: string;
    /** The name of the repo. */
    name?: string;
    /** Whether helm-oci support should be enabled for this repo. */
    enableOci?: boolean;
    /** Github App Private Key PEM data. */
    githubAppPrivateKey?: string;
    /** Github App ID of the app used to access the repo. */
    githubAppID?: string;
    /** Github App Installation ID of the installed GitHub App. */
    githubAppInstallationID?: string;
    /** Github App Enterprise base url if empty will default to https://api.github.com. */
    githubAppEnterpriseBaseUrl?: string;
    /** HTTP/HTTPS proxy to access the repository. */
    proxy?: string;
    /** Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity. */
    project?: string;
}
export interface RequestBody$RepositoryService_ValidateAccess {
    "application/json": string;
}
export interface Response$RepositoryService_ValidateAccess$Status$200 {
    "application/json": Schemas.repositoryRepoResponse;
}
export interface Response$RepositoryService_ValidateAccess$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$RepositoryService_GetAppDetails {
    /** RepoURL is the URL to the repository (Git or Helm) that contains the application manifests */
    "source.repoURL": string;
}
export interface RequestBody$RepositoryService_GetAppDetails {
    "application/json": Schemas.repositoryRepoAppDetailsQuery;
}
export interface Response$RepositoryService_GetAppDetails$Status$200 {
    "application/json": Schemas.repositoryRepoAppDetailsResponse;
}
export interface Response$RepositoryService_GetAppDetails$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface RequestBody$SessionService_Create {
    "application/json": Schemas.sessionSessionCreateRequest;
}
export interface Response$SessionService_Create$Status$200 {
    "application/json": Schemas.sessionSessionResponse;
}
export interface Response$SessionService_Create$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Response$SessionService_Delete$Status$200 {
    "application/json": Schemas.sessionSessionResponse;
}
export interface Response$SessionService_Delete$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Response$SessionService_GetUserInfo$Status$200 {
    "application/json": Schemas.sessionGetUserInfoResponse;
}
export interface Response$SessionService_GetUserInfo$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Response$SettingsService_Get$Status$200 {
    "application/json": Schemas.clusterSettings;
}
export interface Response$SettingsService_Get$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_Watch {
    /** the application's name. */
    name?: string;
    /** forces application reconciliation if set to true. */
    refresh?: string;
    /** the project names to restrict returned list applications. */
    project?: string[];
    /** when specified with a watch call, shows changes that occur after that particular version of a resource. */
    resourceVersion?: string;
    /** the selector to to restrict returned list to applications only with matched labels. */
    selector?: string;
    /** the repoURL to restrict returned list applications. */
    repo?: string;
}
export interface Response$ApplicationService_Watch$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.v1alpha1ApplicationWatchEvent;
    };
}
export interface Response$ApplicationService_Watch$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Parameter$ApplicationService_WatchResourceTree {
    applicationName: string;
    namespace?: string;
    name?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ApplicationService_WatchResourceTree$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.v1alpha1ApplicationTree;
    };
}
export interface Response$ApplicationService_WatchResourceTree$Status$default {
    "application/json": Schemas.runtimeError;
}
export interface Response$VersionService_Version$Status$200 {
    "application/json": Schemas.versionVersionMessage;
}
export interface Response$VersionService_Version$Status$default {
    "application/json": Schemas.runtimeError;
}
export type ResponseContentType$AccountService_ListAccounts = keyof Response$AccountService_ListAccounts$Status$200;
export type ResponseContentType$AccountService_CanI = keyof Response$AccountService_CanI$Status$200;
export interface Params$AccountService_CanI {
    parameter: Parameter$AccountService_CanI;
}
export type RequestContentType$AccountService_UpdatePassword = keyof RequestBody$AccountService_UpdatePassword;
export type ResponseContentType$AccountService_UpdatePassword = keyof Response$AccountService_UpdatePassword$Status$200;
export interface Params$AccountService_UpdatePassword {
    requestBody: RequestBody$AccountService_UpdatePassword["application/json"];
}
export type ResponseContentType$AccountService_GetAccount = keyof Response$AccountService_GetAccount$Status$200;
export interface Params$AccountService_GetAccount {
    parameter: Parameter$AccountService_GetAccount;
}
export type RequestContentType$AccountService_CreateToken = keyof RequestBody$AccountService_CreateToken;
export type ResponseContentType$AccountService_CreateToken = keyof Response$AccountService_CreateToken$Status$200;
export interface Params$AccountService_CreateToken {
    parameter: Parameter$AccountService_CreateToken;
    requestBody: RequestBody$AccountService_CreateToken["application/json"];
}
export type ResponseContentType$AccountService_DeleteToken = keyof Response$AccountService_DeleteToken$Status$200;
export interface Params$AccountService_DeleteToken {
    parameter: Parameter$AccountService_DeleteToken;
}
export type ResponseContentType$ApplicationService_List = keyof Response$ApplicationService_List$Status$200;
export interface Params$ApplicationService_List {
    parameter: Parameter$ApplicationService_List;
}
export type RequestContentType$ApplicationService_Create = keyof RequestBody$ApplicationService_Create;
export type ResponseContentType$ApplicationService_Create = keyof Response$ApplicationService_Create$Status$200;
export interface Params$ApplicationService_Create {
    parameter: Parameter$ApplicationService_Create;
    requestBody: RequestBody$ApplicationService_Create["application/json"];
}
export type RequestContentType$ApplicationService_Update = keyof RequestBody$ApplicationService_Update;
export type ResponseContentType$ApplicationService_Update = keyof Response$ApplicationService_Update$Status$200;
export interface Params$ApplicationService_Update {
    parameter: Parameter$ApplicationService_Update;
    requestBody: RequestBody$ApplicationService_Update["application/json"];
}
export type ResponseContentType$ApplicationService_ManagedResources = keyof Response$ApplicationService_ManagedResources$Status$200;
export interface Params$ApplicationService_ManagedResources {
    parameter: Parameter$ApplicationService_ManagedResources;
}
export type ResponseContentType$ApplicationService_ResourceTree = keyof Response$ApplicationService_ResourceTree$Status$200;
export interface Params$ApplicationService_ResourceTree {
    parameter: Parameter$ApplicationService_ResourceTree;
}
export type ResponseContentType$ApplicationService_Get = keyof Response$ApplicationService_Get$Status$200;
export interface Params$ApplicationService_Get {
    parameter: Parameter$ApplicationService_Get;
}
export type ResponseContentType$ApplicationService_Delete = keyof Response$ApplicationService_Delete$Status$200;
export interface Params$ApplicationService_Delete {
    parameter: Parameter$ApplicationService_Delete;
}
export type RequestContentType$ApplicationService_Patch = keyof RequestBody$ApplicationService_Patch;
export type ResponseContentType$ApplicationService_Patch = keyof Response$ApplicationService_Patch$Status$200;
export interface Params$ApplicationService_Patch {
    parameter: Parameter$ApplicationService_Patch;
    requestBody: RequestBody$ApplicationService_Patch["application/json"];
}
export type ResponseContentType$ApplicationService_ListResourceEvents = keyof Response$ApplicationService_ListResourceEvents$Status$200;
export interface Params$ApplicationService_ListResourceEvents {
    parameter: Parameter$ApplicationService_ListResourceEvents;
}
export type ResponseContentType$ApplicationService_PodLogs2 = keyof Response$ApplicationService_PodLogs2$Status$200;
export interface Params$ApplicationService_PodLogs2 {
    parameter: Parameter$ApplicationService_PodLogs2;
}
export type ResponseContentType$ApplicationService_GetManifests = keyof Response$ApplicationService_GetManifests$Status$200;
export interface Params$ApplicationService_GetManifests {
    parameter: Parameter$ApplicationService_GetManifests;
}
export type ResponseContentType$ApplicationService_TerminateOperation = keyof Response$ApplicationService_TerminateOperation$Status$200;
export interface Params$ApplicationService_TerminateOperation {
    parameter: Parameter$ApplicationService_TerminateOperation;
}
export type ResponseContentType$ApplicationService_PodLogs = keyof Response$ApplicationService_PodLogs$Status$200;
export interface Params$ApplicationService_PodLogs {
    parameter: Parameter$ApplicationService_PodLogs;
}
export type ResponseContentType$ApplicationService_GetResource = keyof Response$ApplicationService_GetResource$Status$200;
export interface Params$ApplicationService_GetResource {
    parameter: Parameter$ApplicationService_GetResource;
}
export type RequestContentType$ApplicationService_PatchResource = keyof RequestBody$ApplicationService_PatchResource;
export type ResponseContentType$ApplicationService_PatchResource = keyof Response$ApplicationService_PatchResource$Status$200;
export interface Params$ApplicationService_PatchResource {
    parameter: Parameter$ApplicationService_PatchResource;
    requestBody: RequestBody$ApplicationService_PatchResource["application/json"];
}
export type ResponseContentType$ApplicationService_DeleteResource = keyof Response$ApplicationService_DeleteResource$Status$200;
export interface Params$ApplicationService_DeleteResource {
    parameter: Parameter$ApplicationService_DeleteResource;
}
export type ResponseContentType$ApplicationService_ListResourceActions = keyof Response$ApplicationService_ListResourceActions$Status$200;
export interface Params$ApplicationService_ListResourceActions {
    parameter: Parameter$ApplicationService_ListResourceActions;
}
export type RequestContentType$ApplicationService_RunResourceAction = keyof RequestBody$ApplicationService_RunResourceAction;
export type ResponseContentType$ApplicationService_RunResourceAction = keyof Response$ApplicationService_RunResourceAction$Status$200;
export interface Params$ApplicationService_RunResourceAction {
    parameter: Parameter$ApplicationService_RunResourceAction;
    requestBody: RequestBody$ApplicationService_RunResourceAction["application/json"];
}
export type ResponseContentType$ApplicationService_RevisionMetadata = keyof Response$ApplicationService_RevisionMetadata$Status$200;
export interface Params$ApplicationService_RevisionMetadata {
    parameter: Parameter$ApplicationService_RevisionMetadata;
}
export type RequestContentType$ApplicationService_Rollback = keyof RequestBody$ApplicationService_Rollback;
export type ResponseContentType$ApplicationService_Rollback = keyof Response$ApplicationService_Rollback$Status$200;
export interface Params$ApplicationService_Rollback {
    parameter: Parameter$ApplicationService_Rollback;
    requestBody: RequestBody$ApplicationService_Rollback["application/json"];
}
export type RequestContentType$ApplicationService_UpdateSpec = keyof RequestBody$ApplicationService_UpdateSpec;
export type ResponseContentType$ApplicationService_UpdateSpec = keyof Response$ApplicationService_UpdateSpec$Status$200;
export interface Params$ApplicationService_UpdateSpec {
    parameter: Parameter$ApplicationService_UpdateSpec;
    requestBody: RequestBody$ApplicationService_UpdateSpec["application/json"];
}
export type RequestContentType$ApplicationService_Sync = keyof RequestBody$ApplicationService_Sync;
export type ResponseContentType$ApplicationService_Sync = keyof Response$ApplicationService_Sync$Status$200;
export interface Params$ApplicationService_Sync {
    parameter: Parameter$ApplicationService_Sync;
    requestBody: RequestBody$ApplicationService_Sync["application/json"];
}
export type ResponseContentType$ApplicationService_GetApplicationSyncWindows = keyof Response$ApplicationService_GetApplicationSyncWindows$Status$200;
export interface Params$ApplicationService_GetApplicationSyncWindows {
    parameter: Parameter$ApplicationService_GetApplicationSyncWindows;
}
export type ResponseContentType$CertificateService_ListCertificates = keyof Response$CertificateService_ListCertificates$Status$200;
export interface Params$CertificateService_ListCertificates {
    parameter: Parameter$CertificateService_ListCertificates;
}
export type RequestContentType$CertificateService_CreateCertificate = keyof RequestBody$CertificateService_CreateCertificate;
export type ResponseContentType$CertificateService_CreateCertificate = keyof Response$CertificateService_CreateCertificate$Status$200;
export interface Params$CertificateService_CreateCertificate {
    parameter: Parameter$CertificateService_CreateCertificate;
    requestBody: RequestBody$CertificateService_CreateCertificate["application/json"];
}
export type ResponseContentType$CertificateService_DeleteCertificate = keyof Response$CertificateService_DeleteCertificate$Status$200;
export interface Params$CertificateService_DeleteCertificate {
    parameter: Parameter$CertificateService_DeleteCertificate;
}
export type ResponseContentType$ClusterService_List = keyof Response$ClusterService_List$Status$200;
export interface Params$ClusterService_List {
    parameter: Parameter$ClusterService_List;
}
export type RequestContentType$ClusterService_Create = keyof RequestBody$ClusterService_Create;
export type ResponseContentType$ClusterService_Create = keyof Response$ClusterService_Create$Status$200;
export interface Params$ClusterService_Create {
    parameter: Parameter$ClusterService_Create;
    requestBody: RequestBody$ClusterService_Create["application/json"];
}
export type RequestContentType$ClusterService_Update = keyof RequestBody$ClusterService_Update;
export type ResponseContentType$ClusterService_Update = keyof Response$ClusterService_Update$Status$200;
export interface Params$ClusterService_Update {
    parameter: Parameter$ClusterService_Update;
    requestBody: RequestBody$ClusterService_Update["application/json"];
}
export type ResponseContentType$ClusterService_Get = keyof Response$ClusterService_Get$Status$200;
export interface Params$ClusterService_Get {
    parameter: Parameter$ClusterService_Get;
}
export type ResponseContentType$ClusterService_Delete = keyof Response$ClusterService_Delete$Status$200;
export interface Params$ClusterService_Delete {
    parameter: Parameter$ClusterService_Delete;
}
export type ResponseContentType$ClusterService_InvalidateCache = keyof Response$ClusterService_InvalidateCache$Status$200;
export interface Params$ClusterService_InvalidateCache {
    parameter: Parameter$ClusterService_InvalidateCache;
}
export type ResponseContentType$ClusterService_RotateAuth = keyof Response$ClusterService_RotateAuth$Status$200;
export interface Params$ClusterService_RotateAuth {
    parameter: Parameter$ClusterService_RotateAuth;
}
export type ResponseContentType$GPGKeyService_List = keyof Response$GPGKeyService_List$Status$200;
export interface Params$GPGKeyService_List {
    parameter: Parameter$GPGKeyService_List;
}
export type RequestContentType$GPGKeyService_Create = keyof RequestBody$GPGKeyService_Create;
export type ResponseContentType$GPGKeyService_Create = keyof Response$GPGKeyService_Create$Status$200;
export interface Params$GPGKeyService_Create {
    parameter: Parameter$GPGKeyService_Create;
    requestBody: RequestBody$GPGKeyService_Create["application/json"];
}
export type ResponseContentType$GPGKeyService_Delete = keyof Response$GPGKeyService_Delete$Status$200;
export interface Params$GPGKeyService_Delete {
    parameter: Parameter$GPGKeyService_Delete;
}
export type ResponseContentType$GPGKeyService_Get = keyof Response$GPGKeyService_Get$Status$200;
export interface Params$GPGKeyService_Get {
    parameter: Parameter$GPGKeyService_Get;
}
export type ResponseContentType$ProjectService_List = keyof Response$ProjectService_List$Status$200;
export interface Params$ProjectService_List {
    parameter: Parameter$ProjectService_List;
}
export type RequestContentType$ProjectService_Create = keyof RequestBody$ProjectService_Create;
export type ResponseContentType$ProjectService_Create = keyof Response$ProjectService_Create$Status$200;
export interface Params$ProjectService_Create {
    requestBody: RequestBody$ProjectService_Create["application/json"];
}
export type ResponseContentType$ProjectService_Get = keyof Response$ProjectService_Get$Status$200;
export interface Params$ProjectService_Get {
    parameter: Parameter$ProjectService_Get;
}
export type ResponseContentType$ProjectService_Delete = keyof Response$ProjectService_Delete$Status$200;
export interface Params$ProjectService_Delete {
    parameter: Parameter$ProjectService_Delete;
}
export type ResponseContentType$ProjectService_GetDetailedProject = keyof Response$ProjectService_GetDetailedProject$Status$200;
export interface Params$ProjectService_GetDetailedProject {
    parameter: Parameter$ProjectService_GetDetailedProject;
}
export type ResponseContentType$ProjectService_ListEvents = keyof Response$ProjectService_ListEvents$Status$200;
export interface Params$ProjectService_ListEvents {
    parameter: Parameter$ProjectService_ListEvents;
}
export type ResponseContentType$ProjectService_GetGlobalProjects = keyof Response$ProjectService_GetGlobalProjects$Status$200;
export interface Params$ProjectService_GetGlobalProjects {
    parameter: Parameter$ProjectService_GetGlobalProjects;
}
export type ResponseContentType$ProjectService_GetSyncWindowsState = keyof Response$ProjectService_GetSyncWindowsState$Status$200;
export interface Params$ProjectService_GetSyncWindowsState {
    parameter: Parameter$ProjectService_GetSyncWindowsState;
}
export type RequestContentType$ProjectService_Update = keyof RequestBody$ProjectService_Update;
export type ResponseContentType$ProjectService_Update = keyof Response$ProjectService_Update$Status$200;
export interface Params$ProjectService_Update {
    parameter: Parameter$ProjectService_Update;
    requestBody: RequestBody$ProjectService_Update["application/json"];
}
export type RequestContentType$ProjectService_CreateToken = keyof RequestBody$ProjectService_CreateToken;
export type ResponseContentType$ProjectService_CreateToken = keyof Response$ProjectService_CreateToken$Status$200;
export interface Params$ProjectService_CreateToken {
    parameter: Parameter$ProjectService_CreateToken;
    requestBody: RequestBody$ProjectService_CreateToken["application/json"];
}
export type ResponseContentType$ProjectService_DeleteToken = keyof Response$ProjectService_DeleteToken$Status$200;
export interface Params$ProjectService_DeleteToken {
    parameter: Parameter$ProjectService_DeleteToken;
}
export type ResponseContentType$RepoCredsService_ListRepositoryCredentials = keyof Response$RepoCredsService_ListRepositoryCredentials$Status$200;
export interface Params$RepoCredsService_ListRepositoryCredentials {
    parameter: Parameter$RepoCredsService_ListRepositoryCredentials;
}
export type RequestContentType$RepoCredsService_CreateRepositoryCredentials = keyof RequestBody$RepoCredsService_CreateRepositoryCredentials;
export type ResponseContentType$RepoCredsService_CreateRepositoryCredentials = keyof Response$RepoCredsService_CreateRepositoryCredentials$Status$200;
export interface Params$RepoCredsService_CreateRepositoryCredentials {
    parameter: Parameter$RepoCredsService_CreateRepositoryCredentials;
    requestBody: RequestBody$RepoCredsService_CreateRepositoryCredentials["application/json"];
}
export type RequestContentType$RepoCredsService_UpdateRepositoryCredentials = keyof RequestBody$RepoCredsService_UpdateRepositoryCredentials;
export type ResponseContentType$RepoCredsService_UpdateRepositoryCredentials = keyof Response$RepoCredsService_UpdateRepositoryCredentials$Status$200;
export interface Params$RepoCredsService_UpdateRepositoryCredentials {
    parameter: Parameter$RepoCredsService_UpdateRepositoryCredentials;
    requestBody: RequestBody$RepoCredsService_UpdateRepositoryCredentials["application/json"];
}
export type ResponseContentType$RepoCredsService_DeleteRepositoryCredentials = keyof Response$RepoCredsService_DeleteRepositoryCredentials$Status$200;
export interface Params$RepoCredsService_DeleteRepositoryCredentials {
    parameter: Parameter$RepoCredsService_DeleteRepositoryCredentials;
}
export type ResponseContentType$RepositoryService_ListRepositories = keyof Response$RepositoryService_ListRepositories$Status$200;
export interface Params$RepositoryService_ListRepositories {
    parameter: Parameter$RepositoryService_ListRepositories;
}
export type RequestContentType$RepositoryService_CreateRepository = keyof RequestBody$RepositoryService_CreateRepository;
export type ResponseContentType$RepositoryService_CreateRepository = keyof Response$RepositoryService_CreateRepository$Status$200;
export interface Params$RepositoryService_CreateRepository {
    parameter: Parameter$RepositoryService_CreateRepository;
    requestBody: RequestBody$RepositoryService_CreateRepository["application/json"];
}
export type RequestContentType$RepositoryService_UpdateRepository = keyof RequestBody$RepositoryService_UpdateRepository;
export type ResponseContentType$RepositoryService_UpdateRepository = keyof Response$RepositoryService_UpdateRepository$Status$200;
export interface Params$RepositoryService_UpdateRepository {
    parameter: Parameter$RepositoryService_UpdateRepository;
    requestBody: RequestBody$RepositoryService_UpdateRepository["application/json"];
}
export type ResponseContentType$RepositoryService_Get = keyof Response$RepositoryService_Get$Status$200;
export interface Params$RepositoryService_Get {
    parameter: Parameter$RepositoryService_Get;
}
export type ResponseContentType$RepositoryService_DeleteRepository = keyof Response$RepositoryService_DeleteRepository$Status$200;
export interface Params$RepositoryService_DeleteRepository {
    parameter: Parameter$RepositoryService_DeleteRepository;
}
export type ResponseContentType$RepositoryService_ListApps = keyof Response$RepositoryService_ListApps$Status$200;
export interface Params$RepositoryService_ListApps {
    parameter: Parameter$RepositoryService_ListApps;
}
export type ResponseContentType$RepositoryService_GetHelmCharts = keyof Response$RepositoryService_GetHelmCharts$Status$200;
export interface Params$RepositoryService_GetHelmCharts {
    parameter: Parameter$RepositoryService_GetHelmCharts;
}
export type ResponseContentType$RepositoryService_ListRefs = keyof Response$RepositoryService_ListRefs$Status$200;
export interface Params$RepositoryService_ListRefs {
    parameter: Parameter$RepositoryService_ListRefs;
}
export type RequestContentType$RepositoryService_ValidateAccess = keyof RequestBody$RepositoryService_ValidateAccess;
export type ResponseContentType$RepositoryService_ValidateAccess = keyof Response$RepositoryService_ValidateAccess$Status$200;
export interface Params$RepositoryService_ValidateAccess {
    parameter: Parameter$RepositoryService_ValidateAccess;
    requestBody: RequestBody$RepositoryService_ValidateAccess["application/json"];
}
export type RequestContentType$RepositoryService_GetAppDetails = keyof RequestBody$RepositoryService_GetAppDetails;
export type ResponseContentType$RepositoryService_GetAppDetails = keyof Response$RepositoryService_GetAppDetails$Status$200;
export interface Params$RepositoryService_GetAppDetails {
    parameter: Parameter$RepositoryService_GetAppDetails;
    requestBody: RequestBody$RepositoryService_GetAppDetails["application/json"];
}
export type RequestContentType$SessionService_Create = keyof RequestBody$SessionService_Create;
export type ResponseContentType$SessionService_Create = keyof Response$SessionService_Create$Status$200;
export interface Params$SessionService_Create {
    requestBody: RequestBody$SessionService_Create["application/json"];
}
export type ResponseContentType$SessionService_Delete = keyof Response$SessionService_Delete$Status$200;
export type ResponseContentType$SessionService_GetUserInfo = keyof Response$SessionService_GetUserInfo$Status$200;
export type ResponseContentType$SettingsService_Get = keyof Response$SettingsService_Get$Status$200;
export type ResponseContentType$ApplicationService_Watch = keyof Response$ApplicationService_Watch$Status$200;
export interface Params$ApplicationService_Watch {
    parameter: Parameter$ApplicationService_Watch;
}
export type ResponseContentType$ApplicationService_WatchResourceTree = keyof Response$ApplicationService_WatchResourceTree$Status$200;
export interface Params$ApplicationService_WatchResourceTree {
    parameter: Parameter$ApplicationService_WatchResourceTree;
}
export type ResponseContentType$VersionService_Version = keyof Response$VersionService_Version$Status$200;
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$AccountService_ListAccounts$Status$200 | Response$AccountService_CanI$Status$200 | Response$AccountService_UpdatePassword$Status$200 | Response$AccountService_GetAccount$Status$200 | Response$AccountService_CreateToken$Status$200 | Response$AccountService_DeleteToken$Status$200 | Response$ApplicationService_List$Status$200 | Response$ApplicationService_Create$Status$200 | Response$ApplicationService_Update$Status$200 | Response$ApplicationService_ManagedResources$Status$200 | Response$ApplicationService_ResourceTree$Status$200 | Response$ApplicationService_Get$Status$200 | Response$ApplicationService_Delete$Status$200 | Response$ApplicationService_Patch$Status$200 | Response$ApplicationService_ListResourceEvents$Status$200 | Response$ApplicationService_PodLogs2$Status$200 | Response$ApplicationService_GetManifests$Status$200 | Response$ApplicationService_TerminateOperation$Status$200 | Response$ApplicationService_PodLogs$Status$200 | Response$ApplicationService_GetResource$Status$200 | Response$ApplicationService_PatchResource$Status$200 | Response$ApplicationService_DeleteResource$Status$200 | Response$ApplicationService_ListResourceActions$Status$200 | Response$ApplicationService_RunResourceAction$Status$200 | Response$ApplicationService_RevisionMetadata$Status$200 | Response$ApplicationService_Rollback$Status$200 | Response$ApplicationService_UpdateSpec$Status$200 | Response$ApplicationService_Sync$Status$200 | Response$ApplicationService_GetApplicationSyncWindows$Status$200 | Response$CertificateService_ListCertificates$Status$200 | Response$CertificateService_CreateCertificate$Status$200 | Response$CertificateService_DeleteCertificate$Status$200 | Response$ClusterService_List$Status$200 | Response$ClusterService_Create$Status$200 | Response$ClusterService_Update$Status$200 | Response$ClusterService_Get$Status$200 | Response$ClusterService_Delete$Status$200 | Response$ClusterService_InvalidateCache$Status$200 | Response$ClusterService_RotateAuth$Status$200 | Response$GPGKeyService_List$Status$200 | Response$GPGKeyService_Create$Status$200 | Response$GPGKeyService_Delete$Status$200 | Response$GPGKeyService_Get$Status$200 | Response$ProjectService_List$Status$200 | Response$ProjectService_Create$Status$200 | Response$ProjectService_Get$Status$200 | Response$ProjectService_Delete$Status$200 | Response$ProjectService_GetDetailedProject$Status$200 | Response$ProjectService_ListEvents$Status$200 | Response$ProjectService_GetGlobalProjects$Status$200 | Response$ProjectService_GetSyncWindowsState$Status$200 | Response$ProjectService_Update$Status$200 | Response$ProjectService_CreateToken$Status$200 | Response$ProjectService_DeleteToken$Status$200 | Response$RepoCredsService_ListRepositoryCredentials$Status$200 | Response$RepoCredsService_CreateRepositoryCredentials$Status$200 | Response$RepoCredsService_UpdateRepositoryCredentials$Status$200 | Response$RepoCredsService_DeleteRepositoryCredentials$Status$200 | Response$RepositoryService_ListRepositories$Status$200 | Response$RepositoryService_CreateRepository$Status$200 | Response$RepositoryService_UpdateRepository$Status$200 | Response$RepositoryService_Get$Status$200 | Response$RepositoryService_DeleteRepository$Status$200 | Response$RepositoryService_ListApps$Status$200 | Response$RepositoryService_GetHelmCharts$Status$200 | Response$RepositoryService_ListRefs$Status$200 | Response$RepositoryService_ValidateAccess$Status$200 | Response$RepositoryService_GetAppDetails$Status$200 | Response$SessionService_Create$Status$200 | Response$SessionService_Delete$Status$200 | Response$SessionService_GetUserInfo$Status$200 | Response$SettingsService_Get$Status$200 | Response$ApplicationService_Watch$Status$200 | Response$ApplicationService_WatchResourceTree$Status$200 | Response$VersionService_Version$Status$200;
export namespace ErrorResponse {
    export type AccountService_ListAccounts = void;
    export type AccountService_CanI = void;
    export type AccountService_UpdatePassword = void;
    export type AccountService_GetAccount = void;
    export type AccountService_CreateToken = void;
    export type AccountService_DeleteToken = void;
    export type ApplicationService_List = void;
    export type ApplicationService_Create = void;
    export type ApplicationService_Update = void;
    export type ApplicationService_ManagedResources = void;
    export type ApplicationService_ResourceTree = void;
    export type ApplicationService_Get = void;
    export type ApplicationService_Delete = void;
    export type ApplicationService_Patch = void;
    export type ApplicationService_ListResourceEvents = void;
    export type ApplicationService_PodLogs2 = void;
    export type ApplicationService_GetManifests = void;
    export type ApplicationService_TerminateOperation = void;
    export type ApplicationService_PodLogs = void;
    export type ApplicationService_GetResource = void;
    export type ApplicationService_PatchResource = void;
    export type ApplicationService_DeleteResource = void;
    export type ApplicationService_ListResourceActions = void;
    export type ApplicationService_RunResourceAction = void;
    export type ApplicationService_RevisionMetadata = void;
    export type ApplicationService_Rollback = void;
    export type ApplicationService_UpdateSpec = void;
    export type ApplicationService_Sync = void;
    export type ApplicationService_GetApplicationSyncWindows = void;
    export type CertificateService_ListCertificates = void;
    export type CertificateService_CreateCertificate = void;
    export type CertificateService_DeleteCertificate = void;
    export type ClusterService_List = void;
    export type ClusterService_Create = void;
    export type ClusterService_Update = void;
    export type ClusterService_Get = void;
    export type ClusterService_Delete = void;
    export type ClusterService_InvalidateCache = void;
    export type ClusterService_RotateAuth = void;
    export type GPGKeyService_List = void;
    export type GPGKeyService_Create = void;
    export type GPGKeyService_Delete = void;
    export type GPGKeyService_Get = void;
    export type ProjectService_List = void;
    export type ProjectService_Create = void;
    export type ProjectService_Get = void;
    export type ProjectService_Delete = void;
    export type ProjectService_GetDetailedProject = void;
    export type ProjectService_ListEvents = void;
    export type ProjectService_GetGlobalProjects = void;
    export type ProjectService_GetSyncWindowsState = void;
    export type ProjectService_Update = void;
    export type ProjectService_CreateToken = void;
    export type ProjectService_DeleteToken = void;
    export type RepoCredsService_ListRepositoryCredentials = void;
    export type RepoCredsService_CreateRepositoryCredentials = void;
    export type RepoCredsService_UpdateRepositoryCredentials = void;
    export type RepoCredsService_DeleteRepositoryCredentials = void;
    export type RepositoryService_ListRepositories = void;
    export type RepositoryService_CreateRepository = void;
    export type RepositoryService_UpdateRepository = void;
    export type RepositoryService_Get = void;
    export type RepositoryService_DeleteRepository = void;
    export type RepositoryService_ListApps = void;
    export type RepositoryService_GetHelmCharts = void;
    export type RepositoryService_ListRefs = void;
    export type RepositoryService_ValidateAccess = void;
    export type RepositoryService_GetAppDetails = void;
    export type SessionService_Create = void;
    export type SessionService_Delete = void;
    export type SessionService_GetUserInfo = void;
    export type SettingsService_Get = void;
    export type ApplicationService_Watch = void;
    export type ApplicationService_WatchResourceTree = void;
    export type VersionService_Version = void;
}
export interface Encoding {
    readonly contentType?: string;
    headers?: Record<string, any>;
    readonly style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    readonly explode?: boolean;
    readonly allowReserved?: boolean;
}
export interface RequestArgs {
    readonly httpMethod: HttpMethod;
    readonly url: string;
    headers: ObjectLike | any;
    requestBody?: ObjectLike | any;
    requestBodyEncoding?: Record<string, Encoding>;
    queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\/$/, ""); }
    /**
     * ListAccounts returns the list of accounts
     * operationId: AccountService_ListAccounts
     * Request URI: /api/v1/account
     */
    public async AccountService_ListAccounts(option?: RequestOption): Promise<Response$AccountService_ListAccounts$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * CanI checks if the current account has permission to perform an action
     * operationId: AccountService_CanI
     * Request URI: /api/v1/account/can-i/{resource}/{action}/{subresource}
     */
    public async AccountService_CanI(params: Params$AccountService_CanI, option?: RequestOption): Promise<Response$AccountService_CanI$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/can-i/${params.parameter.resource}/${params.parameter.action}/${params.parameter.subresource}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * UpdatePassword updates an account's password to a new value
     * operationId: AccountService_UpdatePassword
     * Request URI: /api/v1/account/password
     */
    public async AccountService_UpdatePassword(params: Params$AccountService_UpdatePassword, option?: RequestOption): Promise<Response$AccountService_UpdatePassword$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/password`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * GetAccount returns an account
     * operationId: AccountService_GetAccount
     * Request URI: /api/v1/account/{name}
     */
    public async AccountService_GetAccount(params: Params$AccountService_GetAccount, option?: RequestOption): Promise<Response$AccountService_GetAccount$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * CreateToken creates a token
     * operationId: AccountService_CreateToken
     * Request URI: /api/v1/account/{name}/token
     */
    public async AccountService_CreateToken(params: Params$AccountService_CreateToken, option?: RequestOption): Promise<Response$AccountService_CreateToken$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/${params.parameter.name}/token`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * DeleteToken deletes a token
     * operationId: AccountService_DeleteToken
     * Request URI: /api/v1/account/{name}/token/{id}
     */
    public async AccountService_DeleteToken(params: Params$AccountService_DeleteToken, option?: RequestOption): Promise<Response$AccountService_DeleteToken$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/${params.parameter.name}/token/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List returns list of applications
     * operationId: ApplicationService_List
     * Request URI: /api/v1/applications
     */
    public async ApplicationService_List(params: Params$ApplicationService_List, option?: RequestOption): Promise<Response$ApplicationService_List$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            refresh: { value: params.parameter.refresh, explode: false },
            project: { value: params.parameter.project, explode: true },
            resourceVersion: { value: params.parameter.resourceVersion, explode: false },
            selector: { value: params.parameter.selector, explode: false },
            repo: { value: params.parameter.repo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create creates an application
     * operationId: ApplicationService_Create
     * Request URI: /api/v1/applications
     */
    public async ApplicationService_Create(params: Params$ApplicationService_Create, option?: RequestOption): Promise<Response$ApplicationService_Create$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            upsert: { value: params.parameter.upsert, explode: false },
            validate: { value: params.parameter.validate, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Update updates an application
     * operationId: ApplicationService_Update
     * Request URI: /api/v1/applications/{application.metadata.name}
     */
    public async ApplicationService_Update(params: Params$ApplicationService_Update, option?: RequestOption): Promise<Response$ApplicationService_Update$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter["application.metadata.name"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            validate: { value: params.parameter.validate, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * ManagedResources returns list of managed resources
     * operationId: ApplicationService_ManagedResources
     * Request URI: /api/v1/applications/{applicationName}/managed-resources
     */
    public async ApplicationService_ManagedResources(params: Params$ApplicationService_ManagedResources, option?: RequestOption): Promise<Response$ApplicationService_ManagedResources$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.applicationName}/managed-resources`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            name: { value: params.parameter.name, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * ResourceTree returns resource tree
     * operationId: ApplicationService_ResourceTree
     * Request URI: /api/v1/applications/{applicationName}/resource-tree
     */
    public async ApplicationService_ResourceTree(params: Params$ApplicationService_ResourceTree, option?: RequestOption): Promise<Response$ApplicationService_ResourceTree$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.applicationName}/resource-tree`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            name: { value: params.parameter.name, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get returns an application by name
     * operationId: ApplicationService_Get
     * Request URI: /api/v1/applications/{name}
     */
    public async ApplicationService_Get(params: Params$ApplicationService_Get, option?: RequestOption): Promise<Response$ApplicationService_Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            refresh: { value: params.parameter.refresh, explode: false },
            project: { value: params.parameter.project, explode: true },
            resourceVersion: { value: params.parameter.resourceVersion, explode: false },
            selector: { value: params.parameter.selector, explode: false },
            repo: { value: params.parameter.repo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Delete deletes an application
     * operationId: ApplicationService_Delete
     * Request URI: /api/v1/applications/{name}
     */
    public async ApplicationService_Delete(params: Params$ApplicationService_Delete, option?: RequestOption): Promise<Response$ApplicationService_Delete$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            cascade: { value: params.parameter.cascade, explode: false },
            propagationPolicy: { value: params.parameter.propagationPolicy, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Patch patch an application
     * operationId: ApplicationService_Patch
     * Request URI: /api/v1/applications/{name}
     */
    public async ApplicationService_Patch(params: Params$ApplicationService_Patch, option?: RequestOption): Promise<Response$ApplicationService_Patch$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * ListResourceEvents returns a list of event resources
     * operationId: ApplicationService_ListResourceEvents
     * Request URI: /api/v1/applications/{name}/events
     */
    public async ApplicationService_ListResourceEvents(params: Params$ApplicationService_ListResourceEvents, option?: RequestOption): Promise<Response$ApplicationService_ListResourceEvents$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/events`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            resourceNamespace: { value: params.parameter.resourceNamespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            resourceUID: { value: params.parameter.resourceUID, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * PodLogs returns stream of log entries for the specified pod. Pod
     * operationId: ApplicationService_PodLogs2
     * Request URI: /api/v1/applications/{name}/logs
     */
    public async ApplicationService_PodLogs2(params: Params$ApplicationService_PodLogs2, option?: RequestOption): Promise<Response$ApplicationService_PodLogs2$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/logs`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            podName: { value: params.parameter.podName, explode: false },
            container: { value: params.parameter.container, explode: false },
            sinceSeconds: { value: params.parameter.sinceSeconds, explode: false },
            "sinceTime.seconds": { value: params.parameter["sinceTime.seconds"], explode: false },
            "sinceTime.nanos": { value: params.parameter["sinceTime.nanos"], explode: false },
            tailLines: { value: params.parameter.tailLines, explode: false },
            follow: { value: params.parameter.follow, explode: false },
            untilTime: { value: params.parameter.untilTime, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            kind: { value: params.parameter.kind, explode: false },
            group: { value: params.parameter.group, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            previous: { value: params.parameter.previous, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * GetManifests returns application manifests
     * operationId: ApplicationService_GetManifests
     * Request URI: /api/v1/applications/{name}/manifests
     */
    public async ApplicationService_GetManifests(params: Params$ApplicationService_GetManifests, option?: RequestOption): Promise<Response$ApplicationService_GetManifests$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/manifests`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            revision: { value: params.parameter.revision, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * TerminateOperation terminates the currently running operation
     * operationId: ApplicationService_TerminateOperation
     * Request URI: /api/v1/applications/{name}/operation
     */
    public async ApplicationService_TerminateOperation(params: Params$ApplicationService_TerminateOperation, option?: RequestOption): Promise<Response$ApplicationService_TerminateOperation$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/operation`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * PodLogs returns stream of log entries for the specified pod. Pod
     * operationId: ApplicationService_PodLogs
     * Request URI: /api/v1/applications/{name}/pods/{podName}/logs
     */
    public async ApplicationService_PodLogs(params: Params$ApplicationService_PodLogs, option?: RequestOption): Promise<Response$ApplicationService_PodLogs$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/pods/${params.parameter.podName}/logs`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            container: { value: params.parameter.container, explode: false },
            sinceSeconds: { value: params.parameter.sinceSeconds, explode: false },
            "sinceTime.seconds": { value: params.parameter["sinceTime.seconds"], explode: false },
            "sinceTime.nanos": { value: params.parameter["sinceTime.nanos"], explode: false },
            tailLines: { value: params.parameter.tailLines, explode: false },
            follow: { value: params.parameter.follow, explode: false },
            untilTime: { value: params.parameter.untilTime, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            kind: { value: params.parameter.kind, explode: false },
            group: { value: params.parameter.group, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            previous: { value: params.parameter.previous, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * GetResource returns single application resource
     * operationId: ApplicationService_GetResource
     * Request URI: /api/v1/applications/{name}/resource
     */
    public async ApplicationService_GetResource(params: Params$ApplicationService_GetResource, option?: RequestOption): Promise<Response$ApplicationService_GetResource$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * PatchResource patch single application resource
     * operationId: ApplicationService_PatchResource
     * Request URI: /api/v1/applications/{name}/resource
     */
    public async ApplicationService_PatchResource(params: Params$ApplicationService_PatchResource, option?: RequestOption): Promise<Response$ApplicationService_PatchResource$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false },
            patchType: { value: params.parameter.patchType, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * DeleteResource deletes a single application resource
     * operationId: ApplicationService_DeleteResource
     * Request URI: /api/v1/applications/{name}/resource
     */
    public async ApplicationService_DeleteResource(params: Params$ApplicationService_DeleteResource, option?: RequestOption): Promise<Response$ApplicationService_DeleteResource$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false },
            force: { value: params.parameter.force, explode: false },
            orphan: { value: params.parameter.orphan, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * ListResourceActions returns list of resource actions
     * operationId: ApplicationService_ListResourceActions
     * Request URI: /api/v1/applications/{name}/resource/actions
     */
    public async ApplicationService_ListResourceActions(params: Params$ApplicationService_ListResourceActions, option?: RequestOption): Promise<Response$ApplicationService_ListResourceActions$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource/actions`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * RunResourceAction run resource action
     * operationId: ApplicationService_RunResourceAction
     * Request URI: /api/v1/applications/{name}/resource/actions
     */
    public async ApplicationService_RunResourceAction(params: Params$ApplicationService_RunResourceAction, option?: RequestOption): Promise<Response$ApplicationService_RunResourceAction$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource/actions`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get the meta-data (author, date, tags, message) for a specific revision of the application
     * operationId: ApplicationService_RevisionMetadata
     * Request URI: /api/v1/applications/{name}/revisions/{revision}/metadata
     */
    public async ApplicationService_RevisionMetadata(params: Params$ApplicationService_RevisionMetadata, option?: RequestOption): Promise<Response$ApplicationService_RevisionMetadata$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/revisions/${params.parameter.revision}/metadata`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Rollback syncs an application to its target state
     * operationId: ApplicationService_Rollback
     * Request URI: /api/v1/applications/{name}/rollback
     */
    public async ApplicationService_Rollback(params: Params$ApplicationService_Rollback, option?: RequestOption): Promise<Response$ApplicationService_Rollback$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/rollback`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * UpdateSpec updates an application spec
     * operationId: ApplicationService_UpdateSpec
     * Request URI: /api/v1/applications/{name}/spec
     */
    public async ApplicationService_UpdateSpec(params: Params$ApplicationService_UpdateSpec, option?: RequestOption): Promise<Response$ApplicationService_UpdateSpec$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/spec`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            validate: { value: params.parameter.validate, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Sync syncs an application to its target state
     * operationId: ApplicationService_Sync
     * Request URI: /api/v1/applications/{name}/sync
     */
    public async ApplicationService_Sync(params: Params$ApplicationService_Sync, option?: RequestOption): Promise<Response$ApplicationService_Sync$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/sync`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get returns sync windows of the application
     * operationId: ApplicationService_GetApplicationSyncWindows
     * Request URI: /api/v1/applications/{name}/syncwindows
     */
    public async ApplicationService_GetApplicationSyncWindows(params: Params$ApplicationService_GetApplicationSyncWindows, option?: RequestOption): Promise<Response$ApplicationService_GetApplicationSyncWindows$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/syncwindows`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List all available repository certificates
     * operationId: CertificateService_ListCertificates
     * Request URI: /api/v1/certificates
     */
    public async CertificateService_ListCertificates(params: Params$CertificateService_ListCertificates, option?: RequestOption): Promise<Response$CertificateService_ListCertificates$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/certificates`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            hostNamePattern: { value: params.parameter.hostNamePattern, explode: false },
            certType: { value: params.parameter.certType, explode: false },
            certSubType: { value: params.parameter.certSubType, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Creates repository certificates on the server
     * operationId: CertificateService_CreateCertificate
     * Request URI: /api/v1/certificates
     */
    public async CertificateService_CreateCertificate(params: Params$CertificateService_CreateCertificate, option?: RequestOption): Promise<Response$CertificateService_CreateCertificate$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/certificates`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            upsert: { value: params.parameter.upsert, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Delete the certificates that match the RepositoryCertificateQuery
     * operationId: CertificateService_DeleteCertificate
     * Request URI: /api/v1/certificates
     */
    public async CertificateService_DeleteCertificate(params: Params$CertificateService_DeleteCertificate, option?: RequestOption): Promise<Response$CertificateService_DeleteCertificate$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/certificates`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            hostNamePattern: { value: params.parameter.hostNamePattern, explode: false },
            certType: { value: params.parameter.certType, explode: false },
            certSubType: { value: params.parameter.certSubType, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List returns list of clusters
     * operationId: ClusterService_List
     * Request URI: /api/v1/clusters
     */
    public async ClusterService_List(params: Params$ClusterService_List, option?: RequestOption): Promise<Response$ClusterService_List$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            server: { value: params.parameter.server, explode: false },
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create creates a cluster
     * operationId: ClusterService_Create
     * Request URI: /api/v1/clusters
     */
    public async ClusterService_Create(params: Params$ClusterService_Create, option?: RequestOption): Promise<Response$ClusterService_Create$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            upsert: { value: params.parameter.upsert, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Update updates a cluster
     * operationId: ClusterService_Update
     * Request URI: /api/v1/clusters/{cluster.server}
     */
    public async ClusterService_Update(params: Params$ClusterService_Update, option?: RequestOption): Promise<Response$ClusterService_Update$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter["cluster.server"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            updatedFields: { value: params.parameter.updatedFields, explode: true }
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get returns a cluster by server address
     * operationId: ClusterService_Get
     * Request URI: /api/v1/clusters/{server}
     */
    public async ClusterService_Get(params: Params$ClusterService_Get, option?: RequestOption): Promise<Response$ClusterService_Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Delete deletes a cluster
     * operationId: ClusterService_Delete
     * Request URI: /api/v1/clusters/{server}
     */
    public async ClusterService_Delete(params: Params$ClusterService_Delete, option?: RequestOption): Promise<Response$ClusterService_Delete$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * InvalidateCache invalidates cluster cache
     * operationId: ClusterService_InvalidateCache
     * Request URI: /api/v1/clusters/{server}/invalidate-cache
     */
    public async ClusterService_InvalidateCache(params: Params$ClusterService_InvalidateCache, option?: RequestOption): Promise<Response$ClusterService_InvalidateCache$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}/invalidate-cache`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * RotateAuth rotates the bearer token used for a cluster
     * operationId: ClusterService_RotateAuth
     * Request URI: /api/v1/clusters/{server}/rotate-auth
     */
    public async ClusterService_RotateAuth(params: Params$ClusterService_RotateAuth, option?: RequestOption): Promise<Response$ClusterService_RotateAuth$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}/rotate-auth`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List all available repository certificates
     * operationId: GPGKeyService_List
     * Request URI: /api/v1/gpgkeys
     */
    public async GPGKeyService_List(params: Params$GPGKeyService_List, option?: RequestOption): Promise<Response$GPGKeyService_List$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            keyID: { value: params.parameter.keyID, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create one or more GPG public keys in the server's configuration
     * operationId: GPGKeyService_Create
     * Request URI: /api/v1/gpgkeys
     */
    public async GPGKeyService_Create(params: Params$GPGKeyService_Create, option?: RequestOption): Promise<Response$GPGKeyService_Create$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            upsert: { value: params.parameter.upsert, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Delete specified GPG public key from the server's configuration
     * operationId: GPGKeyService_Delete
     * Request URI: /api/v1/gpgkeys
     */
    public async GPGKeyService_Delete(params: Params$GPGKeyService_Delete, option?: RequestOption): Promise<Response$GPGKeyService_Delete$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            keyID: { value: params.parameter.keyID, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get information about specified GPG public key from the server
     * operationId: GPGKeyService_Get
     * Request URI: /api/v1/gpgkeys/{keyID}
     */
    public async GPGKeyService_Get(params: Params$GPGKeyService_Get, option?: RequestOption): Promise<Response$GPGKeyService_Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys/${params.parameter.keyID}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List returns list of projects
     * operationId: ProjectService_List
     * Request URI: /api/v1/projects
     */
    public async ProjectService_List(params: Params$ProjectService_List, option?: RequestOption): Promise<Response$ProjectService_List$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a new project
     * operationId: ProjectService_Create
     * Request URI: /api/v1/projects
     */
    public async ProjectService_Create(params: Params$ProjectService_Create, option?: RequestOption): Promise<Response$ProjectService_Create$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get returns a project by name
     * operationId: ProjectService_Get
     * Request URI: /api/v1/projects/{name}
     */
    public async ProjectService_Get(params: Params$ProjectService_Get, option?: RequestOption): Promise<Response$ProjectService_Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete deletes a project
     * operationId: ProjectService_Delete
     * Request URI: /api/v1/projects/{name}
     */
    public async ProjectService_Delete(params: Params$ProjectService_Delete, option?: RequestOption): Promise<Response$ProjectService_Delete$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * GetDetailedProject returns a project that include project, global project and scoped resources by name
     * operationId: ProjectService_GetDetailedProject
     * Request URI: /api/v1/projects/{name}/detailed
     */
    public async ProjectService_GetDetailedProject(params: Params$ProjectService_GetDetailedProject, option?: RequestOption): Promise<Response$ProjectService_GetDetailedProject$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/detailed`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * ListEvents returns a list of project events
     * operationId: ProjectService_ListEvents
     * Request URI: /api/v1/projects/{name}/events
     */
    public async ProjectService_ListEvents(params: Params$ProjectService_ListEvents, option?: RequestOption): Promise<Response$ProjectService_ListEvents$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/events`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get returns a virtual project by name
     * operationId: ProjectService_GetGlobalProjects
     * Request URI: /api/v1/projects/{name}/globalprojects
     */
    public async ProjectService_GetGlobalProjects(params: Params$ProjectService_GetGlobalProjects, option?: RequestOption): Promise<Response$ProjectService_GetGlobalProjects$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/globalprojects`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * GetSchedulesState returns true if there are any active sync syncWindows
     * operationId: ProjectService_GetSyncWindowsState
     * Request URI: /api/v1/projects/{name}/syncwindows
     */
    public async ProjectService_GetSyncWindowsState(params: Params$ProjectService_GetSyncWindowsState, option?: RequestOption): Promise<Response$ProjectService_GetSyncWindowsState$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/syncwindows`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update updates a project
     * operationId: ProjectService_Update
     * Request URI: /api/v1/projects/{project.metadata.name}
     */
    public async ProjectService_Update(params: Params$ProjectService_Update, option?: RequestOption): Promise<Response$ProjectService_Update$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter["project.metadata.name"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create a new project token
     * operationId: ProjectService_CreateToken
     * Request URI: /api/v1/projects/{project}/roles/{role}/token
     */
    public async ProjectService_CreateToken(params: Params$ProjectService_CreateToken, option?: RequestOption): Promise<Response$ProjectService_CreateToken$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.project}/roles/${params.parameter.role}/token`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a new project token
     * operationId: ProjectService_DeleteToken
     * Request URI: /api/v1/projects/{project}/roles/{role}/token/{iat}
     */
    public async ProjectService_DeleteToken(params: Params$ProjectService_DeleteToken, option?: RequestOption): Promise<Response$ProjectService_DeleteToken$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.project}/roles/${params.parameter.role}/token/${params.parameter.iat}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            id: { value: params.parameter.id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * ListRepositoryCredentials gets a list of all configured repository credential sets
     * operationId: RepoCredsService_ListRepositoryCredentials
     * Request URI: /api/v1/repocreds
     */
    public async RepoCredsService_ListRepositoryCredentials(params: Params$RepoCredsService_ListRepositoryCredentials, option?: RequestOption): Promise<Response$RepoCredsService_ListRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            url: { value: params.parameter.url, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * CreateRepositoryCredentials creates a new repository credential set
     * operationId: RepoCredsService_CreateRepositoryCredentials
     * Request URI: /api/v1/repocreds
     */
    public async RepoCredsService_CreateRepositoryCredentials(params: Params$RepoCredsService_CreateRepositoryCredentials, option?: RequestOption): Promise<Response$RepoCredsService_CreateRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            upsert: { value: params.parameter.upsert, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * UpdateRepositoryCredentials updates a repository credential set
     * operationId: RepoCredsService_UpdateRepositoryCredentials
     * Request URI: /api/v1/repocreds/{creds.url}
     */
    public async RepoCredsService_UpdateRepositoryCredentials(params: Params$RepoCredsService_UpdateRepositoryCredentials, option?: RequestOption): Promise<Response$RepoCredsService_UpdateRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds/${params.parameter["creds.url"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * DeleteRepositoryCredentials deletes a repository credential set from the configuration
     * operationId: RepoCredsService_DeleteRepositoryCredentials
     * Request URI: /api/v1/repocreds/{url}
     */
    public async RepoCredsService_DeleteRepositoryCredentials(params: Params$RepoCredsService_DeleteRepositoryCredentials, option?: RequestOption): Promise<Response$RepoCredsService_DeleteRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds/${params.parameter.url}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * ListRepositories gets a list of all configured repositories
     * operationId: RepositoryService_ListRepositories
     * Request URI: /api/v1/repositories
     */
    public async RepositoryService_ListRepositories(params: Params$RepositoryService_ListRepositories, option?: RequestOption): Promise<Response$RepositoryService_ListRepositories$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            repo: { value: params.parameter.repo, explode: false },
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * CreateRepository creates a new repository configuration
     * operationId: RepositoryService_CreateRepository
     * Request URI: /api/v1/repositories
     */
    public async RepositoryService_CreateRepository(params: Params$RepositoryService_CreateRepository, option?: RequestOption): Promise<Response$RepositoryService_CreateRepository$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            upsert: { value: params.parameter.upsert, explode: false },
            credsOnly: { value: params.parameter.credsOnly, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * UpdateRepository updates a repository configuration
     * operationId: RepositoryService_UpdateRepository
     * Request URI: /api/v1/repositories/{repo.repo}
     */
    public async RepositoryService_UpdateRepository(params: Params$RepositoryService_UpdateRepository, option?: RequestOption): Promise<Response$RepositoryService_UpdateRepository$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter["repo.repo"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get returns a repository or its credentials
     * operationId: RepositoryService_Get
     * Request URI: /api/v1/repositories/{repo}
     */
    public async RepositoryService_Get(params: Params$RepositoryService_Get, option?: RequestOption): Promise<Response$RepositoryService_Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * DeleteRepository deletes a repository from the configuration
     * operationId: RepositoryService_DeleteRepository
     * Request URI: /api/v1/repositories/{repo}
     */
    public async RepositoryService_DeleteRepository(params: Params$RepositoryService_DeleteRepository, option?: RequestOption): Promise<Response$RepositoryService_DeleteRepository$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * ListApps returns list of apps in the repo
     * operationId: RepositoryService_ListApps
     * Request URI: /api/v1/repositories/{repo}/apps
     */
    public async RepositoryService_ListApps(params: Params$RepositoryService_ListApps, option?: RequestOption): Promise<Response$RepositoryService_ListApps$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/apps`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            revision: { value: params.parameter.revision, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * GetHelmCharts returns list of helm charts in the specified repository
     * operationId: RepositoryService_GetHelmCharts
     * Request URI: /api/v1/repositories/{repo}/helmcharts
     */
    public async RepositoryService_GetHelmCharts(params: Params$RepositoryService_GetHelmCharts, option?: RequestOption): Promise<Response$RepositoryService_GetHelmCharts$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/helmcharts`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * operationId: RepositoryService_ListRefs
     * Request URI: /api/v1/repositories/{repo}/refs
     */
    public async RepositoryService_ListRefs(params: Params$RepositoryService_ListRefs, option?: RequestOption): Promise<Response$RepositoryService_ListRefs$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/refs`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * ValidateAccess validates access to a repository with given parameters
     * operationId: RepositoryService_ValidateAccess
     * Request URI: /api/v1/repositories/{repo}/validate
     */
    public async RepositoryService_ValidateAccess(params: Params$RepositoryService_ValidateAccess, option?: RequestOption): Promise<Response$RepositoryService_ValidateAccess$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/validate`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            username: { value: params.parameter.username, explode: false },
            password: { value: params.parameter.password, explode: false },
            sshPrivateKey: { value: params.parameter.sshPrivateKey, explode: false },
            insecure: { value: params.parameter.insecure, explode: false },
            tlsClientCertData: { value: params.parameter.tlsClientCertData, explode: false },
            tlsClientCertKey: { value: params.parameter.tlsClientCertKey, explode: false },
            type: { value: params.parameter.type, explode: false },
            name: { value: params.parameter.name, explode: false },
            enableOci: { value: params.parameter.enableOci, explode: false },
            githubAppPrivateKey: { value: params.parameter.githubAppPrivateKey, explode: false },
            githubAppID: { value: params.parameter.githubAppID, explode: false },
            githubAppInstallationID: { value: params.parameter.githubAppInstallationID, explode: false },
            githubAppEnterpriseBaseUrl: { value: params.parameter.githubAppEnterpriseBaseUrl, explode: false },
            proxy: { value: params.parameter.proxy, explode: false },
            project: { value: params.parameter.project, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * GetAppDetails returns application details by given path
     * operationId: RepositoryService_GetAppDetails
     * Request URI: /api/v1/repositories/{source.repoURL}/appdetails
     */
    public async RepositoryService_GetAppDetails(params: Params$RepositoryService_GetAppDetails, option?: RequestOption): Promise<Response$RepositoryService_GetAppDetails$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter["source.repoURL"]}/appdetails`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create a new JWT for authentication and set a cookie if using HTTP
     * operationId: SessionService_Create
     * Request URI: /api/v1/session
     */
    public async SessionService_Create(params: Params$SessionService_Create, option?: RequestOption): Promise<Response$SessionService_Create$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/session`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an existing JWT cookie if using HTTP
     * operationId: SessionService_Delete
     * Request URI: /api/v1/session
     */
    public async SessionService_Delete(option?: RequestOption): Promise<Response$SessionService_Delete$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/session`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get the current user's info
     * operationId: SessionService_GetUserInfo
     * Request URI: /api/v1/session/userinfo
     */
    public async SessionService_GetUserInfo(option?: RequestOption): Promise<Response$SessionService_GetUserInfo$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/session/userinfo`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get returns Argo CD settings
     * operationId: SettingsService_Get
     * Request URI: /api/v1/settings
     */
    public async SettingsService_Get(option?: RequestOption): Promise<Response$SettingsService_Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/settings`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Watch returns stream of application change events
     * operationId: ApplicationService_Watch
     * Request URI: /api/v1/stream/applications
     */
    public async ApplicationService_Watch(params: Params$ApplicationService_Watch, option?: RequestOption): Promise<Response$ApplicationService_Watch$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/stream/applications`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            refresh: { value: params.parameter.refresh, explode: false },
            project: { value: params.parameter.project, explode: true },
            resourceVersion: { value: params.parameter.resourceVersion, explode: false },
            selector: { value: params.parameter.selector, explode: false },
            repo: { value: params.parameter.repo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Watch returns stream of application resource tree
     * operationId: ApplicationService_WatchResourceTree
     * Request URI: /api/v1/stream/applications/{applicationName}/resource-tree
     */
    public async ApplicationService_WatchResourceTree(params: Params$ApplicationService_WatchResourceTree, option?: RequestOption): Promise<Response$ApplicationService_WatchResourceTree$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/stream/applications/${params.parameter.applicationName}/resource-tree`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            name: { value: params.parameter.name, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Version returns version information of the API server
     * operationId: VersionService_Version
     * Request URI: /api/version
     */
    public async VersionService_Version(option?: RequestOption): Promise<Response$VersionService_Version$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/version`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
}
