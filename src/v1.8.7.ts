// 
// Generated by @himenon/openapi-typescript-code-generator v0.13.2
// 
// OpenApi : 3.0.0
// 
// 


export namespace Schemas {
    export interface accountAccount {
        capabilities?: string[];
        enabled?: boolean;
        name?: string;
        tokens?: Schemas.accountToken[];
    }
    export interface accountAccountsList {
        items?: Schemas.accountAccount[];
    }
    export interface accountCanIResponse {
        value?: string;
    }
    export interface accountCreateTokenRequest {
        expiresIn?: string;
        id?: string;
        name?: string;
    }
    export interface accountCreateTokenResponse {
        token?: string;
    }
    export interface accountEmptyResponse {
    }
    export interface accountToken {
        expiresAt?: string;
        id?: string;
        issuedAt?: string;
    }
    export interface accountUpdatePasswordRequest {
        currentPassword?: string;
        name?: string;
        newPassword?: string;
    }
    export interface accountUpdatePasswordResponse {
    }
    export interface applicationApplicationPatchRequest {
        name?: string;
        patch?: string;
        patchType?: string;
    }
    export interface applicationApplicationResourceResponse {
        manifest?: string;
    }
    export interface applicationApplicationResponse {
    }
    export interface applicationApplicationRollbackRequest {
        dryRun?: boolean;
        id?: string;
        name?: string;
        prune?: boolean;
    }
    export interface applicationApplicationSyncRequest {
        dryRun?: boolean;
        infos?: Schemas.v1alpha1Info[];
        manifests?: string[];
        name?: string;
        prune?: boolean;
        resources?: Schemas.v1alpha1SyncOperationResource[];
        retryStrategy?: Schemas.v1alpha1RetryStrategy;
        revision?: string;
        strategy?: Schemas.v1alpha1SyncStrategy;
    }
    export interface applicationApplicationSyncWindow {
        duration?: string;
        kind?: string;
        manualSync?: boolean;
        schedule?: string;
    }
    export interface applicationApplicationSyncWindowsResponse {
        activeWindows?: Schemas.applicationApplicationSyncWindow[];
        assignedWindows?: Schemas.applicationApplicationSyncWindow[];
        canSync?: boolean;
    }
    export interface applicationLogEntry {
        content?: string;
        last?: boolean;
        timeStamp?: Schemas.v1Time;
    }
    export interface applicationManagedResourcesResponse {
        items?: Schemas.v1alpha1ResourceDiff[];
    }
    export interface applicationOperationTerminateResponse {
    }
    export interface applicationResourceActionsListResponse {
        actions?: Schemas.v1alpha1ResourceAction[];
    }
    export interface applicationv1alpha1EnvEntry {
        name?: string;
        value?: string;
    }
    export interface clusterClusterResponse {
    }
    export interface clusterConnector {
        name?: string;
        type?: string;
    }
    export interface clusterDexConfig {
        connectors?: Schemas.clusterConnector[];
    }
    export interface clusterGoogleAnalyticsConfig {
        anonymizeUsers?: boolean;
        trackingID?: string;
    }
    export interface clusterHelp {
        chatText?: string;
        chatUrl?: string;
    }
    export interface clusterOIDCConfig {
        cliClientID?: string;
        clientID?: string;
        idTokenClaims?: {
            [key: string]: Schemas.oidcClaim;
        };
        issuer?: string;
        name?: string;
        scopes?: string[];
    }
    export interface clusterPlugin {
        name?: string;
    }
    export interface clusterSettings {
        appLabelKey?: string;
        configManagementPlugins?: Schemas.v1alpha1ConfigManagementPlugin[];
        dexConfig?: Schemas.clusterDexConfig;
        googleAnalytics?: Schemas.clusterGoogleAnalyticsConfig;
        help?: Schemas.clusterHelp;
        kustomizeOptions?: Schemas.v1alpha1KustomizeOptions;
        kustomizeVersions?: string[];
        oidcConfig?: Schemas.clusterOIDCConfig;
        plugins?: Schemas.clusterPlugin[];
        resourceOverrides?: {
            [key: string]: Schemas.v1alpha1ResourceOverride;
        };
        statusBadgeEnabled?: boolean;
        uiCssURL?: string;
        url?: string;
        userLoginsDisabled?: boolean;
    }
    export interface gpgkeyGnuPGPublicKeyCreateResponse {
        created?: Schemas.v1alpha1GnuPGPublicKeyList;
        skipped?: string[];
    }
    export interface gpgkeyGnuPGPublicKeyResponse {
    }
    export interface oidcClaim {
        essential?: boolean;
        value?: string;
        values?: string[];
    }
    export interface projectEmptyResponse {
    }
    export interface projectGlobalProjectsResponse {
        items?: Schemas.v1alpha1AppProject[];
    }
    /** ProjectCreateRequest defines project creation parameters. */
    export interface projectProjectCreateRequest {
        project?: Schemas.v1alpha1AppProject;
        upsert?: boolean;
    }
    /** ProjectTokenCreateRequest defines project token creation parameters. */
    export interface projectProjectTokenCreateRequest {
        description?: string;
        expiresIn?: string;
        id?: string;
        project?: string;
        role?: string;
    }
    /** ProjectTokenResponse wraps the created token or returns an empty string if deleted. */
    export interface projectProjectTokenResponse {
        token?: string;
    }
    export interface projectProjectUpdateRequest {
        project?: Schemas.v1alpha1AppProject;
    }
    export interface projectSyncWindowsResponse {
        windows?: Schemas.v1alpha1SyncWindow[];
    }
    export interface protobufAny {
        type_url?: string;
        value?: Blob;
    }
    export interface repocredsRepoCredsResponse {
    }
    export interface repositoryAppInfo {
        path?: string;
        type?: string;
    }
    export interface repositoryDirectoryAppSpec {
    }
    export interface repositoryHelmAppSpec {
        fileParameters?: Schemas.v1alpha1HelmFileParameter[];
        name?: string;
        parameters?: Schemas.v1alpha1HelmParameter[];
        valueFiles?: string[];
        values?: string;
    }
    export interface repositoryHelmChart {
        name?: string;
        versions?: string[];
    }
    export interface repositoryHelmChartsResponse {
        items?: Schemas.repositoryHelmChart[];
    }
    export interface repositoryKsonnetAppSpec {
        environments?: {
            [key: string]: Schemas.repositoryKsonnetEnvironment;
        };
        name?: string;
        parameters?: Schemas.v1alpha1KsonnetParameter[];
    }
    export interface repositoryKsonnetEnvironment {
        destination?: Schemas.repositoryKsonnetEnvironmentDestination;
        /** KubernetesVersion is the kubernetes version the targeted cluster is running on. */
        k8sVersion?: string;
        name?: string;
    }
    export interface repositoryKsonnetEnvironmentDestination {
        namespace?: string;
        /** Server is the Kubernetes server that the cluster is running on. */
        server?: string;
    }
    export interface repositoryKustomizeAppSpec {
        /** images is a list of available images. */
        images?: string[];
    }
    export interface repositoryManifestResponse {
        manifests?: string[];
        namespace?: string;
        revision?: string;
        server?: string;
        sourceType?: string;
        verifyResult?: string;
    }
    export interface repositoryRefs {
        branches?: string[];
        tags?: string[];
    }
    export interface repositoryRepoAppDetailsQuery {
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface repositoryRepoAppDetailsResponse {
        directory?: Schemas.repositoryDirectoryAppSpec;
        helm?: Schemas.repositoryHelmAppSpec;
        ksonnet?: Schemas.repositoryKsonnetAppSpec;
        kustomize?: Schemas.repositoryKustomizeAppSpec;
        type?: string;
    }
    export interface repositoryRepoAppsResponse {
        items?: Schemas.repositoryAppInfo[];
    }
    export interface repositoryRepoResponse {
    }
    export interface runtimeStreamError {
        details?: Schemas.protobufAny[];
        grpc_code?: number;
        http_code?: number;
        http_status?: string;
        message?: string;
    }
    export interface sessionGetUserInfoResponse {
        groups?: string[];
        iss?: string;
        loggedIn?: boolean;
        username?: string;
    }
    /** SessionCreateRequest is for logging in. */
    export interface sessionSessionCreateRequest {
        password?: string;
        token?: string;
        username?: string;
    }
    /** SessionResponse wraps the created token or returns an empty string if deleted. */
    export interface sessionSessionResponse {
        token?: string;
    }
    /** Event is a report of an event somewhere in the cluster. */
    export interface v1Event {
        action?: string;
        count?: number;
        eventTime?: Schemas.v1MicroTime;
        firstTimestamp?: Schemas.v1Time;
        involvedObject?: Schemas.v1ObjectReference;
        lastTimestamp?: Schemas.v1Time;
        message?: string;
        metadata?: Schemas.v1ObjectMeta;
        reason?: string;
        related?: Schemas.v1ObjectReference;
        reportingComponent?: string;
        reportingInstance?: string;
        series?: Schemas.v1EventSeries;
        source?: Schemas.v1EventSource;
        type?: string;
    }
    /** EventList is a list of events. */
    export interface v1EventList {
        items?: Schemas.v1Event[];
        metadata?: Schemas.v1ListMeta;
    }
    /**
     * EventSeries contain information on series of events, i.e. thing that was/is happening
     * continuously for some time.
     */
    export interface v1EventSeries {
        count?: number;
        lastObservedTime?: Schemas.v1MicroTime;
    }
    /** EventSource contains information for an event. */
    export interface v1EventSource {
        component?: string;
        host?: string;
    }
    /**
     * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
     *
     * Each key is either a '.' representing the field itself, and will always map to an empty set,
     * or a string representing a sub-field or item. The string will follow one of these four formats:
     * 'f:<name>', where <name> is the name of a field in a struct, or key in a map
     * 'v:<value>', where <value> is the exact json formatted value of a list item
     * 'i:<index>', where <index> is position of a item in a list
     * 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
     * If a key maps to an empty Fields value, the field that key represents is part of the set.
     *
     * The exact format is defined in sigs.k8s.io/structured-merge-diff
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface v1FieldsV1 {
        /** Raw is the underlying serialization of this object. */
        Raw?: Blob;
    }
    /** +protobuf.options.(gogoproto.goproto_stringer)=false */
    export interface v1GroupKind {
        group?: string;
        kind?: string;
    }
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and
     * various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    export interface v1ListMeta {
        /**
         * continue may be set if the user set a limit on the number of items returned, and indicates that
         * the server has more data available. The value is opaque and may be used to issue another request
         * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
         * consistent list may not be possible if the server configuration has changed or more than a few
         * minutes have passed. The resourceVersion field returned when using this continue value will be
         * identical to the value in the first response, unless you have received this token from an error
         * message.
         */
        continue?: string;
        remainingItemCount?: string;
        resourceVersion?: string;
        /**
         * selfLink is a URL representing this object.
         * Populated by the system.
         * Read-only.
         *
         * DEPRECATED
         * Kubernetes will stop propagating this field in 1.20 release and the field is planned
         * to be removed in 1.21 release.
         * +optional
         */
        selfLink?: string;
    }
    /**
     * LoadBalancerIngress represents the status of a load-balancer ingress point:
     * traffic intended for the service should be sent to an ingress point.
     */
    export interface v1LoadBalancerIngress {
        hostname?: string;
        ip?: string;
    }
    /**
     * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
     * that the fieldset applies to.
     */
    export interface v1ManagedFieldsEntry {
        /**
         * APIVersion defines the version of this resource that this field set
         * applies to. The format is "group/version" just like the top-level
         * APIVersion field. It is necessary to track the version of a field
         * set because it cannot be automatically converted.
         */
        apiVersion?: string;
        fieldsType?: string;
        fieldsV1?: Schemas.v1FieldsV1;
        /** Manager is an identifier of the workflow managing these fields. */
        manager?: string;
        /**
         * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
         * The only valid values for this field are 'Apply' and 'Update'.
         */
        operation?: string;
        time?: Schemas.v1Time;
    }
    /**
     * MicroTime is version of Time with microsecond level precision.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface v1MicroTime {
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive. This field may be limited in precision depending on context.
         */
        nanos?: number;
        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: string;
    }
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects
     * users must create.
     */
    export interface v1ObjectMeta {
        annotations?: {
            [key: string]: string;
        };
        clusterName?: string;
        creationTimestamp?: Schemas.v1Time;
        deletionGracePeriodSeconds?: string;
        deletionTimestamp?: Schemas.v1Time;
        finalizers?: string[];
        /**
         * GenerateName is an optional prefix, used by the server, to generate a unique
         * name ONLY IF the Name field has not been provided.
         * If this field is used, the name returned to the client will be different
         * than the name passed. This value will also be combined with a unique suffix.
         * The provided value has the same validation rules as the Name field,
         * and may be truncated by the length of the suffix required to make the value
         * unique on the server.
         *
         * If this field is specified and the generated name exists, the server will
         * NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
         * ServerTimeout indicating a unique name could not be found in the time allotted, and the client
         * should retry (optionally after the time indicated in the Retry-After header).
         *
         * Applied only if Name is not specified.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
         * +optional
         */
        generateName?: string;
        generation?: string;
        labels?: {
            [key: string]: string;
        };
        /**
         * ManagedFields maps workflow-id and version to the set of fields
         * that are managed by that workflow. This is mostly for internal
         * housekeeping, and users typically shouldn't need to set or
         * understand this field. A workflow can be the user's name, a
         * controller's name, or the name of a specific apply path like
         * "ci-cd". The set of fields is always in the version that the
         * workflow used when modifying the object.
         *
         * +optional
         */
        managedFields?: Schemas.v1ManagedFieldsEntry[];
        name?: string;
        /**
         * Namespace defines the space within which each name must be unique. An empty namespace is
         * equivalent to the "default" namespace, but "default" is the canonical representation.
         * Not all objects are required to be scoped to a namespace - the value of this field for
         * those objects will be empty.
         *
         * Must be a DNS_LABEL.
         * Cannot be updated.
         * More info: http://kubernetes.io/docs/user-guide/namespaces
         * +optional
         */
        namespace?: string;
        ownerReferences?: Schemas.v1OwnerReference[];
        /**
         * An opaque value that represents the internal version of this object that can
         * be used by clients to determine when objects have changed. May be used for optimistic
         * concurrency, change detection, and the watch operation on a resource or set of resources.
         * Clients must treat these values as opaque and passed unmodified back to the server.
         * They may only be valid for a particular resource or set of resources.
         *
         * Populated by the system.
         * Read-only.
         * Value must be treated as opaque by clients and .
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
         * +optional
         */
        resourceVersion?: string;
        /**
         * SelfLink is a URL representing this object.
         * Populated by the system.
         * Read-only.
         *
         * DEPRECATED
         * Kubernetes will stop propagating this field in 1.20 release and the field is planned
         * to be removed in 1.21 release.
         * +optional
         */
        selfLink?: string;
        /**
         * UID is the unique in time and space value for this object. It is typically generated by
         * the server on successful creation of a resource and is not allowed to change on PUT
         * operations.
         *
         * Populated by the system.
         * Read-only.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
         * +optional
         */
        uid?: string;
    }
    export interface v1ObjectReference {
        apiVersion?: string;
        fieldPath?: string;
        kind?: string;
        name?: string;
        namespace?: string;
        resourceVersion?: string;
        uid?: string;
    }
    /**
     * OwnerReference contains enough information to let you identify an owning
     * object. An owning object must be in the same namespace as the dependent, or
     * be cluster-scoped, so there is no namespace field.
     */
    export interface v1OwnerReference {
        /** API version of the referent. */
        apiVersion?: string;
        blockOwnerDeletion?: boolean;
        controller?: boolean;
        kind?: string;
        name?: string;
        uid?: string;
    }
    /**
     * Time is a wrapper around time.Time which supports correct
     * marshaling to YAML and JSON.  Wrappers are provided for many
     * of the factory methods that the time package offers.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface v1Time {
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive. This field may be limited in precision depending on context.
         */
        nanos?: number;
        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: string;
    }
    export interface v1alpha1AWSAuthConfig {
        clusterName?: string;
        /** RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain. */
        roleARN?: string;
    }
    export interface v1alpha1AppProject {
        metadata?: Schemas.v1ObjectMeta;
        spec?: Schemas.v1alpha1AppProjectSpec;
        status?: Schemas.v1alpha1AppProjectStatus;
    }
    export interface v1alpha1AppProjectList {
        items?: Schemas.v1alpha1AppProject[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1AppProjectSpec {
        clusterResourceBlacklist?: Schemas.v1GroupKind[];
        clusterResourceWhitelist?: Schemas.v1GroupKind[];
        description?: string;
        destinations?: Schemas.v1alpha1ApplicationDestination[];
        namespaceResourceBlacklist?: Schemas.v1GroupKind[];
        namespaceResourceWhitelist?: Schemas.v1GroupKind[];
        orphanedResources?: Schemas.v1alpha1OrphanedResourcesMonitorSettings;
        roles?: Schemas.v1alpha1ProjectRole[];
        signatureKeys?: Schemas.v1alpha1SignatureKey[];
        sourceRepos?: string[];
        syncWindows?: Schemas.v1alpha1SyncWindow[];
    }
    export interface v1alpha1AppProjectStatus {
        jwtTokensByRole?: {
            [key: string]: Schemas.v1alpha1JWTTokens;
        };
    }
    export interface v1alpha1Application {
        metadata?: Schemas.v1ObjectMeta;
        operation?: Schemas.v1alpha1Operation;
        spec?: Schemas.v1alpha1ApplicationSpec;
        status?: Schemas.v1alpha1ApplicationStatus;
    }
    export interface v1alpha1ApplicationCondition {
        lastTransitionTime?: Schemas.v1Time;
        message?: string;
        type?: string;
    }
    export interface v1alpha1ApplicationDestination {
        name?: string;
        namespace?: string;
        server?: string;
    }
    export interface v1alpha1ApplicationList {
        items?: Schemas.v1alpha1Application[];
        metadata?: Schemas.v1ListMeta;
    }
    /** ApplicationSource contains information about github repository, path within repository and target application environment. */
    export interface v1alpha1ApplicationSource {
        chart?: string;
        directory?: Schemas.v1alpha1ApplicationSourceDirectory;
        helm?: Schemas.v1alpha1ApplicationSourceHelm;
        ksonnet?: Schemas.v1alpha1ApplicationSourceKsonnet;
        kustomize?: Schemas.v1alpha1ApplicationSourceKustomize;
        path?: string;
        plugin?: Schemas.v1alpha1ApplicationSourcePlugin;
        repoURL?: string;
        targetRevision?: string;
    }
    export interface v1alpha1ApplicationSourceDirectory {
        exclude?: string;
        jsonnet?: Schemas.v1alpha1ApplicationSourceJsonnet;
        recurse?: boolean;
    }
    export interface v1alpha1ApplicationSourceHelm {
        fileParameters?: Schemas.v1alpha1HelmFileParameter[];
        parameters?: Schemas.v1alpha1HelmParameter[];
        releaseName?: string;
        valueFiles?: string[];
        values?: string;
        version?: string;
    }
    export interface v1alpha1ApplicationSourceJsonnet {
        extVars?: Schemas.v1alpha1JsonnetVar[];
        libs?: string[];
        tlas?: Schemas.v1alpha1JsonnetVar[];
    }
    export interface v1alpha1ApplicationSourceKsonnet {
        environment?: string;
        parameters?: Schemas.v1alpha1KsonnetParameter[];
    }
    export interface v1alpha1ApplicationSourceKustomize {
        commonAnnotations?: {
            [key: string]: string;
        };
        commonLabels?: {
            [key: string]: string;
        };
        images?: string[];
        namePrefix?: string;
        nameSuffix?: string;
        version?: string;
    }
    export interface v1alpha1ApplicationSourcePlugin {
        env?: Schemas.applicationv1alpha1EnvEntry[];
        name?: string;
    }
    /** ApplicationSpec represents desired application state. Contains link to repository with application definition and additional parameters link definition revision. */
    export interface v1alpha1ApplicationSpec {
        destination?: Schemas.v1alpha1ApplicationDestination;
        ignoreDifferences?: Schemas.v1alpha1ResourceIgnoreDifferences[];
        info?: Schemas.v1alpha1Info[];
        /** Project is a application project name. Empty name means that application belongs to 'default' project. */
        project?: string;
        /**
         * This limits this number of items kept in the apps revision history.
         * This should only be changed in exceptional circumstances.
         * Setting to zero will store no history. This will reduce storage used.
         * Increasing will increase the space used to store the history, so we do not recommend increasing it.
         * Default is 10.
         */
        revisionHistoryLimit?: string;
        source?: Schemas.v1alpha1ApplicationSource;
        syncPolicy?: Schemas.v1alpha1SyncPolicy;
    }
    export interface v1alpha1ApplicationStatus {
        conditions?: Schemas.v1alpha1ApplicationCondition[];
        health?: Schemas.v1alpha1HealthStatus;
        history?: Schemas.v1alpha1RevisionHistory[];
        observedAt?: Schemas.v1Time;
        operationState?: Schemas.v1alpha1OperationState;
        reconciledAt?: Schemas.v1Time;
        resources?: Schemas.v1alpha1ResourceStatus[];
        sourceType?: string;
        summary?: Schemas.v1alpha1ApplicationSummary;
        sync?: Schemas.v1alpha1SyncStatus;
    }
    export interface v1alpha1ApplicationSummary {
        /** ExternalURLs holds all external URLs of application child resources. */
        externalURLs?: string[];
        /** Images holds all images of application child resources. */
        images?: string[];
    }
    export interface v1alpha1ApplicationTree {
        /** Nodes contains list of nodes which either directly managed by the application and children of directly managed nodes. */
        nodes?: Schemas.v1alpha1ResourceNode[];
        /** OrphanedNodes contains if or orphaned nodes: nodes which are not managed by the app but in the same namespace. List is populated only if orphaned resources enabled in app project. */
        orphanedNodes?: Schemas.v1alpha1ResourceNode[];
    }
    /** ApplicationWatchEvent contains information about application change. */
    export interface v1alpha1ApplicationWatchEvent {
        application?: Schemas.v1alpha1Application;
        type?: string;
    }
    export interface v1alpha1Backoff {
        duration?: string;
        factor?: string;
        maxDuration?: string;
    }
    export interface v1alpha1Cluster {
        config?: Schemas.v1alpha1ClusterConfig;
        connectionState?: Schemas.v1alpha1ConnectionState;
        info?: Schemas.v1alpha1ClusterInfo;
        name?: string;
        /** Holds list of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty. */
        namespaces?: string[];
        refreshRequestedAt?: Schemas.v1Time;
        server?: string;
        serverVersion?: string;
        /** Shard contains optional shard number. Calculated on the fly by the application controller if not specified. */
        shard?: string;
    }
    export interface v1alpha1ClusterCacheInfo {
        apisCount?: string;
        lastCacheSyncTime?: Schemas.v1Time;
        resourcesCount?: string;
    }
    /**
     * ClusterConfig is the configuration attributes. This structure is subset of the go-client
     * rest.Config with annotations added for marshalling.
     */
    export interface v1alpha1ClusterConfig {
        awsAuthConfig?: Schemas.v1alpha1AWSAuthConfig;
        /**
         * Server requires Bearer authentication. This client will not attempt to use
         * refresh tokens for an OAuth2 flow.
         * TODO: demonstrate an OAuth2 compatible client.
         */
        bearerToken?: string;
        execProviderConfig?: Schemas.v1alpha1ExecProviderConfig;
        password?: string;
        tlsClientConfig?: Schemas.v1alpha1TLSClientConfig;
        username?: string;
    }
    export interface v1alpha1ClusterInfo {
        applicationsCount?: string;
        cacheInfo?: Schemas.v1alpha1ClusterCacheInfo;
        connectionState?: Schemas.v1alpha1ConnectionState;
        serverVersion?: string;
    }
    /** ClusterList is a collection of Clusters. */
    export interface v1alpha1ClusterList {
        items?: Schemas.v1alpha1Cluster[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1Command {
        args?: string[];
        command?: string[];
    }
    export interface v1alpha1ComparedTo {
        destination?: Schemas.v1alpha1ApplicationDestination;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface v1alpha1ConfigManagementPlugin {
        generate?: Schemas.v1alpha1Command;
        init?: Schemas.v1alpha1Command;
        name?: string;
    }
    export interface v1alpha1ConnectionState {
        attemptedAt?: Schemas.v1Time;
        message?: string;
        status?: string;
    }
    export interface v1alpha1ExecProviderConfig {
        apiVersion?: string;
        args?: string[];
        command?: string;
        env?: {
            [key: string]: string;
        };
        installHint?: string;
    }
    export interface v1alpha1GnuPGPublicKey {
        fingerprint?: string;
        keyData?: string;
        keyID?: string;
        owner?: string;
        subType?: string;
        trust?: string;
    }
    export interface v1alpha1GnuPGPublicKeyList {
        items?: Schemas.v1alpha1GnuPGPublicKey[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1HealthStatus {
        message?: string;
        status?: string;
    }
    export interface v1alpha1HelmFileParameter {
        name?: string;
        path?: string;
    }
    export interface v1alpha1HelmParameter {
        forceString?: boolean;
        name?: string;
        value?: string;
    }
    export interface v1alpha1Info {
        name?: string;
        value?: string;
    }
    export interface v1alpha1InfoItem {
        /** Name is a human readable title for this piece of information. */
        name?: string;
        /** Value is human readable content. */
        value?: string;
    }
    export interface v1alpha1JWTToken {
        exp?: string;
        iat?: string;
        id?: string;
    }
    export interface v1alpha1JWTTokens {
        items?: Schemas.v1alpha1JWTToken[];
    }
    export interface v1alpha1JsonnetVar {
        code?: boolean;
        name?: string;
        value?: string;
    }
    export interface v1alpha1KnownTypeField {
        field?: string;
        type?: string;
    }
    export interface v1alpha1KsonnetParameter {
        component?: string;
        name?: string;
        value?: string;
    }
    export interface v1alpha1KustomizeOptions {
        binaryPath?: string;
        buildOptions?: string;
    }
    /** Operation contains requested operation parameters. */
    export interface v1alpha1Operation {
        info?: Schemas.v1alpha1Info[];
        initiatedBy?: Schemas.v1alpha1OperationInitiator;
        retry?: Schemas.v1alpha1RetryStrategy;
        sync?: Schemas.v1alpha1SyncOperation;
    }
    export interface v1alpha1OperationInitiator {
        /** Automated is set to true if operation was initiated automatically by the application controller. */
        automated?: boolean;
        /** Name of a user who started operation. */
        username?: string;
    }
    /** OperationState contains information about state of currently performing operation on application. */
    export interface v1alpha1OperationState {
        finishedAt?: Schemas.v1Time;
        /** Message hold any pertinent messages when attempting to perform operation (typically errors). */
        message?: string;
        operation?: Schemas.v1alpha1Operation;
        phase?: string;
        retryCount?: string;
        startedAt?: Schemas.v1Time;
        syncResult?: Schemas.v1alpha1SyncOperationResult;
    }
    export interface v1alpha1OrphanedResourceKey {
        group?: string;
        kind?: string;
        name?: string;
    }
    export interface v1alpha1OrphanedResourcesMonitorSettings {
        ignore?: Schemas.v1alpha1OrphanedResourceKey[];
        warn?: boolean;
    }
    export interface v1alpha1OverrideIgnoreDiff {
        jSONPointers?: string[];
    }
    export interface v1alpha1ProjectRole {
        description?: string;
        groups?: string[];
        jwtTokens?: Schemas.v1alpha1JWTToken[];
        name?: string;
        policies?: string[];
    }
    export interface v1alpha1RepoCreds {
        password?: string;
        sshPrivateKey?: string;
        tlsClientCertData?: string;
        tlsClientCertKey?: string;
        url?: string;
        username?: string;
    }
    /** RepositoryList is a collection of Repositories. */
    export interface v1alpha1RepoCredsList {
        items?: Schemas.v1alpha1RepoCreds[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1Repository {
        connectionState?: Schemas.v1alpha1ConnectionState;
        enableLfs?: boolean;
        enableOCI?: boolean;
        inheritedCreds?: boolean;
        insecure?: boolean;
        insecureIgnoreHostKey?: boolean;
        name?: string;
        password?: string;
        repo?: string;
        sshPrivateKey?: string;
        tlsClientCertData?: string;
        tlsClientCertKey?: string;
        type?: string;
        username?: string;
    }
    export interface v1alpha1RepositoryCertificate {
        certData?: Blob;
        certInfo?: string;
        certSubType?: string;
        certType?: string;
        serverName?: string;
    }
    export interface v1alpha1RepositoryCertificateList {
        items?: Schemas.v1alpha1RepositoryCertificate[];
        metadata?: Schemas.v1ListMeta;
    }
    /** RepositoryList is a collection of Repositories. */
    export interface v1alpha1RepositoryList {
        items?: Schemas.v1alpha1Repository[];
        metadata?: Schemas.v1ListMeta;
    }
    export interface v1alpha1ResourceAction {
        disabled?: boolean;
        name?: string;
        params?: Schemas.v1alpha1ResourceActionParam[];
    }
    export interface v1alpha1ResourceActionParam {
        default?: string;
        name?: string;
        type?: string;
        value?: string;
    }
    export interface v1alpha1ResourceDiff {
        diff?: string;
        group?: string;
        hook?: boolean;
        kind?: string;
        liveState?: string;
        name?: string;
        namespace?: string;
        normalizedLiveState?: string;
        predictedLiveState?: string;
        targetState?: string;
    }
    /** ResourceIgnoreDifferences contains resource filter and list of json paths which should be ignored during comparison with live state. */
    export interface v1alpha1ResourceIgnoreDifferences {
        group?: string;
        jsonPointers?: string[];
        kind?: string;
        name?: string;
        namespace?: string;
    }
    export interface v1alpha1ResourceNetworkingInfo {
        /** ExternalURLs holds list of URLs which should be available externally. List is populated for ingress resources using rules hostnames. */
        externalURLs?: string[];
        ingress?: Schemas.v1LoadBalancerIngress[];
        labels?: {
            [key: string]: string;
        };
        targetLabels?: {
            [key: string]: string;
        };
        targetRefs?: Schemas.v1alpha1ResourceRef[];
    }
    export interface v1alpha1ResourceNode {
        createdAt?: Schemas.v1Time;
        health?: Schemas.v1alpha1HealthStatus;
        images?: string[];
        info?: Schemas.v1alpha1InfoItem[];
        networkingInfo?: Schemas.v1alpha1ResourceNetworkingInfo;
        parentRefs?: Schemas.v1alpha1ResourceRef[];
        resourceRef?: Schemas.v1alpha1ResourceRef;
        resourceVersion?: string;
    }
    export interface v1alpha1ResourceOverride {
        actions?: string;
        healthLua?: string;
        ignoreDifferences?: Schemas.v1alpha1OverrideIgnoreDiff;
        knownTypeFields?: Schemas.v1alpha1KnownTypeField[];
    }
    export interface v1alpha1ResourceRef {
        group?: string;
        kind?: string;
        name?: string;
        namespace?: string;
        uid?: string;
        version?: string;
    }
    export interface v1alpha1ResourceResult {
        group?: string;
        hookPhase?: string;
        hookType?: string;
        kind?: string;
        message?: string;
        name?: string;
        namespace?: string;
        status?: string;
        syncPhase?: string;
        version?: string;
    }
    export interface v1alpha1ResourceStatus {
        group?: string;
        health?: Schemas.v1alpha1HealthStatus;
        hook?: boolean;
        kind?: string;
        name?: string;
        namespace?: string;
        requiresPruning?: boolean;
        status?: string;
        version?: string;
    }
    export interface v1alpha1RetryStrategy {
        backoff?: Schemas.v1alpha1Backoff;
        limit?: string;
    }
    export interface v1alpha1RevisionHistory {
        deployStartedAt?: Schemas.v1Time;
        deployedAt?: Schemas.v1Time;
        id?: string;
        revision?: string;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface v1alpha1RevisionMetadata {
        author?: string;
        date?: Schemas.v1Time;
        message?: string;
        signatureInfo?: string;
        tags?: string[];
    }
    export interface v1alpha1SignatureKey {
        keyID?: string;
    }
    /** SyncOperation contains sync operation details. */
    export interface v1alpha1SyncOperation {
        dryRun?: boolean;
        manifests?: string[];
        prune?: boolean;
        resources?: Schemas.v1alpha1SyncOperationResource[];
        /**
         * Revision is the revision in which to sync the application to.
         * If omitted, will use the revision specified in app spec.
         */
        revision?: string;
        source?: Schemas.v1alpha1ApplicationSource;
        syncOptions?: string[];
        syncStrategy?: Schemas.v1alpha1SyncStrategy;
    }
    /** SyncOperationResource contains resources to sync. */
    export interface v1alpha1SyncOperationResource {
        group?: string;
        kind?: string;
        name?: string;
        namespace?: string;
    }
    export interface v1alpha1SyncOperationResult {
        resources?: Schemas.v1alpha1ResourceResult[];
        revision?: string;
        source?: Schemas.v1alpha1ApplicationSource;
    }
    export interface v1alpha1SyncPolicy {
        automated?: Schemas.v1alpha1SyncPolicyAutomated;
        retry?: Schemas.v1alpha1RetryStrategy;
        syncOptions?: string[];
    }
    export interface v1alpha1SyncPolicyAutomated {
        allowEmpty?: boolean;
        prune?: boolean;
        selfHeal?: boolean;
    }
    /** SyncStatus is a comparison result of application spec and deployed application. */
    export interface v1alpha1SyncStatus {
        comparedTo?: Schemas.v1alpha1ComparedTo;
        revision?: string;
        status?: string;
    }
    export interface v1alpha1SyncStrategy {
        apply?: Schemas.v1alpha1SyncStrategyApply;
        hook?: Schemas.v1alpha1SyncStrategyHook;
    }
    export interface v1alpha1SyncStrategyApply {
        /**
         * Force indicates whether or not to supply the --force flag to `kubectl apply`.
         * The --force flag deletes and re-create the resource, when PATCH encounters conflict and has
         * retried for 5 times.
         */
        force?: boolean;
    }
    /**
     * SyncStrategyHook will perform a sync using hooks annotations.
     * If no hook annotation is specified falls back to `kubectl apply`.
     */
    export interface v1alpha1SyncStrategyHook {
        syncStrategyApply?: Schemas.v1alpha1SyncStrategyApply;
    }
    export interface v1alpha1SyncWindow {
        applications?: string[];
        clusters?: string[];
        duration?: string;
        kind?: string;
        manualSync?: boolean;
        namespaces?: string[];
        schedule?: string;
    }
    export interface v1alpha1TLSClientConfig {
        caData?: Blob;
        certData?: Blob;
        /** Server should be accessed without verifying the TLS certificate. For testing only. */
        insecure?: boolean;
        keyData?: Blob;
        /**
         * ServerName is passed to the server for SNI and is used in the client to check server
         * certificates against. If ServerName is empty, the hostname used to contact the
         * server is used.
         */
        serverName?: string;
    }
    export interface versionVersionMessage {
        BuildDate?: string;
        Compiler?: string;
        GitCommit?: string;
        GitTag?: string;
        GitTreeState?: string;
        GoVersion?: string;
        HelmVersion?: string;
        JsonnetVersion?: string;
        KsonnetVersion?: string;
        KubectlVersion?: string;
        KustomizeVersion?: string;
        Platform?: string;
        Version?: string;
    }
}
export namespace RequestBodies {
    export namespace v1alpha1Application {
        export interface Content {
            "application/json": Schemas.v1alpha1Application;
        }
    }
    export namespace PatchResourceBody {
        export interface Content {
            "application/json": string;
        }
    }
    export namespace v1alpha1Cluster {
        export interface Content {
            "application/json": Schemas.v1alpha1Cluster;
        }
    }
}
export interface Response$ListAccounts$Status$200 {
    "application/json": Schemas.accountAccountsList;
}
export interface Parameter$CanI {
    resource: string;
    action: string;
    subresource: string;
}
export interface Response$CanI$Status$200 {
    "application/json": Schemas.accountCanIResponse;
}
export interface RequestBody$UpdatePassword {
    "application/json": Schemas.accountUpdatePasswordRequest;
}
export interface Response$UpdatePassword$Status$200 {
    "application/json": Schemas.accountUpdatePasswordResponse;
}
export interface Parameter$GetAccount {
    name: string;
}
export interface Response$GetAccount$Status$200 {
    "application/json": Schemas.accountAccount;
}
export interface Parameter$CreateToken {
    name: string;
}
export interface RequestBody$CreateToken {
    "application/json": Schemas.accountCreateTokenRequest;
}
export interface Response$CreateToken$Status$200 {
    "application/json": Schemas.accountCreateTokenResponse;
}
export interface Parameter$DeleteToken {
    name: string;
    id: string;
}
export interface Response$DeleteToken$Status$200 {
    "application/json": Schemas.accountEmptyResponse;
}
export interface Parameter$List {
    /** the application's name. */
    name?: string;
    /** forces application reconciliation if set to true. */
    refresh?: string;
    /** the project names to restrict returned list applications. */
    project?: string[];
    /** when specified with a watch call, shows changes that occur after that particular version of a resource. */
    resourceVersion?: string;
    /** the selector to to restrict returned list to applications only with matched labels. */
    selector?: string;
}
export interface Response$List$Status$200 {
    "application/json": Schemas.v1alpha1ApplicationList;
}
export type RequestBody$Create = RequestBodies.v1alpha1Application.Content;
export interface Response$Create$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Parameter$Update {
    /**
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: http://kubernetes.io/docs/user-guide/identifiers#names
     * +optional
     */
    "application.metadata.name": string;
}
export type RequestBody$Update = RequestBodies.v1alpha1Application.Content;
export interface Response$Update$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Parameter$ManagedResources {
    applicationName: string;
    namespace?: string;
    name?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ManagedResources$Status$200 {
    "application/json": Schemas.applicationManagedResourcesResponse;
}
export interface Parameter$ResourceTree {
    applicationName: string;
    namespace?: string;
    name?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ResourceTree$Status$200 {
    "application/json": Schemas.v1alpha1ApplicationTree;
}
export interface Parameter$Get {
    /** the application's name */
    name: string;
    /** forces application reconciliation if set to true. */
    refresh?: string;
    /** the project names to restrict returned list applications. */
    project?: string[];
    /** when specified with a watch call, shows changes that occur after that particular version of a resource. */
    resourceVersion?: string;
    /** the selector to to restrict returned list to applications only with matched labels. */
    selector?: string;
}
export interface Response$Get$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Parameter$Delete {
    name: string;
    cascade?: boolean;
}
export interface Response$Delete$Status$200 {
    "application/json": Schemas.applicationApplicationResponse;
}
export interface Parameter$Patch {
    name: string;
}
export interface RequestBody$Patch {
    "application/json": Schemas.applicationApplicationPatchRequest;
}
export interface Response$Patch$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Parameter$ListResourceEvents {
    name: string;
    resourceNamespace?: string;
    resourceName?: string;
    resourceUID?: string;
}
export interface Response$ListResourceEvents$Status$200 {
    "application/json": Schemas.v1EventList;
}
export interface Parameter$GetManifests {
    name: string;
    revision?: string;
}
export interface Response$GetManifests$Status$200 {
    "application/json": Schemas.repositoryManifestResponse;
}
export interface Parameter$TerminateOperation {
    name: string;
}
export interface Response$TerminateOperation$Status$200 {
    "application/json": Schemas.applicationOperationTerminateResponse;
}
export interface Parameter$PodLogs {
    name: string;
    podName: string;
    namespace?: string;
    container?: string;
    sinceSeconds?: string;
    /**
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     */
    "sinceTime.seconds"?: string;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     */
    "sinceTime.nanos"?: number;
    tailLines?: string;
    follow?: boolean;
}
export interface Response$PodLogs$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.applicationLogEntry;
    };
}
export interface Parameter$GetResource {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$GetResource$Status$200 {
    "application/json": Schemas.applicationApplicationResourceResponse;
}
export interface Parameter$PatchResource {
    name: string;
}
export type RequestBody$PatchResource = RequestBodies.PatchResourceBody.Content;
export interface Response$PatchResource$Status$200 {
    "application/json": Schemas.applicationApplicationResourceResponse;
}
export interface Parameter$DeleteResource {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
    force?: boolean;
}
export interface Response$DeleteResource$Status$200 {
    "application/json": Schemas.applicationApplicationResponse;
}
export interface Parameter$ListResourceActions {
    name: string;
    namespace?: string;
    resourceName?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$ListResourceActions$Status$200 {
    "application/json": Schemas.applicationResourceActionsListResponse;
}
export interface Parameter$RunResourceAction {
    name: string;
}
export type RequestBody$RunResourceAction = RequestBodies.PatchResourceBody.Content;
export interface Response$RunResourceAction$Status$200 {
    "application/json": Schemas.applicationApplicationResponse;
}
export interface Parameter$RevisionMetadata {
    /** the application's name */
    name: string;
    /** the revision of the app */
    revision: string;
}
export interface Response$RevisionMetadata$Status$200 {
    "application/json": Schemas.v1alpha1RevisionMetadata;
}
export interface Parameter$Rollback {
    name: string;
}
export interface RequestBody$Rollback {
    "application/json": Schemas.applicationApplicationRollbackRequest;
}
export interface Response$Rollback$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Parameter$UpdateSpec {
    name: string;
}
export interface RequestBody$UpdateSpec {
    "application/json": Schemas.v1alpha1ApplicationSpec;
}
export interface Response$UpdateSpec$Status$200 {
    "application/json": Schemas.v1alpha1ApplicationSpec;
}
export interface Parameter$Sync {
    name: string;
}
export interface RequestBody$Sync {
    "application/json": Schemas.applicationApplicationSyncRequest;
}
export interface Response$Sync$Status$200 {
    "application/json": Schemas.v1alpha1Application;
}
export interface Parameter$GetApplicationSyncWindows {
    name: string;
}
export interface Response$GetApplicationSyncWindows$Status$200 {
    "application/json": Schemas.applicationApplicationSyncWindowsResponse;
}
export interface Parameter$ListCertificates {
    /** A file-glob pattern (not regular expression) the host name has to match. */
    hostNamePattern?: string;
    /** The type of the certificate to match (ssh or https). */
    certType?: string;
    /** The sub type of the certificate to match (protocol dependent, usually only used for ssh certs). */
    certSubType?: string;
}
export interface Response$ListCertificates$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface RequestBody$CreateCertificate {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Response$CreateCertificate$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Parameter$DeleteCertificate {
    /** A file-glob pattern (not regular expression) the host name has to match. */
    hostNamePattern?: string;
    /** The type of the certificate to match (ssh or https). */
    certType?: string;
    /** The sub type of the certificate to match (protocol dependent, usually only used for ssh certs). */
    certSubType?: string;
}
export interface Response$DeleteCertificate$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryCertificateList;
}
export interface Parameter$ListMixin3 {
    server?: string;
    name?: string;
}
export interface Response$ListMixin3$Status$200 {
    "application/json": Schemas.v1alpha1ClusterList;
}
export type RequestBody$CreateMixin3 = RequestBodies.v1alpha1Cluster.Content;
export interface Response$CreateMixin3$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Parameter$UpdateMixin3 {
    /** Server is the API server URL of the Kubernetes cluster */
    "cluster.server": string;
}
export type RequestBody$UpdateMixin3 = RequestBodies.v1alpha1Cluster.Content;
export interface Response$UpdateMixin3$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Parameter$GetMixin3 {
    server: string;
    name?: string;
}
export interface Response$GetMixin3$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Parameter$DeleteMixin3 {
    server: string;
    name?: string;
}
export interface Response$DeleteMixin3$Status$200 {
    "application/json": Schemas.clusterClusterResponse;
}
export interface Parameter$InvalidateCache {
    server: string;
}
export interface Response$InvalidateCache$Status$200 {
    "application/json": Schemas.v1alpha1Cluster;
}
export interface Parameter$RotateAuth {
    server: string;
}
export interface Response$RotateAuth$Status$200 {
    "application/json": Schemas.clusterClusterResponse;
}
export interface Parameter$ListMixin4 {
    /** The GPG key ID to query for. */
    keyID?: string;
}
export interface Response$ListMixin4$Status$200 {
    "application/json": Schemas.v1alpha1GnuPGPublicKeyList;
}
export interface RequestBody$CreateMixin4 {
    "application/json": Schemas.v1alpha1GnuPGPublicKey;
}
export interface Response$CreateMixin4$Status$200 {
    "application/json": Schemas.gpgkeyGnuPGPublicKeyCreateResponse;
}
export interface Parameter$DeleteMixin4 {
    /** The GPG key ID to query for. */
    keyID?: string;
}
export interface Response$DeleteMixin4$Status$200 {
    "application/json": Schemas.gpgkeyGnuPGPublicKeyResponse;
}
export interface Parameter$GetMixin4 {
    /** The GPG key ID to query for */
    keyID: string;
}
export interface Response$GetMixin4$Status$200 {
    "application/json": Schemas.v1alpha1GnuPGPublicKey;
}
export interface Parameter$ListMixin5 {
    name?: string;
}
export interface Response$ListMixin5$Status$200 {
    "application/json": Schemas.v1alpha1AppProjectList;
}
export interface RequestBody$CreateMixin5 {
    "application/json": Schemas.projectProjectCreateRequest;
}
export interface Response$CreateMixin5$Status$200 {
    "application/json": Schemas.v1alpha1AppProject;
}
export interface Parameter$GetMixin5 {
    name: string;
}
export interface Response$GetMixin5$Status$200 {
    "application/json": Schemas.v1alpha1AppProject;
}
export interface Parameter$DeleteMixin5 {
    name: string;
}
export interface Response$DeleteMixin5$Status$200 {
    "application/json": Schemas.projectEmptyResponse;
}
export interface Parameter$ListEvents {
    name: string;
}
export interface Response$ListEvents$Status$200 {
    "application/json": Schemas.v1EventList;
}
export interface Parameter$GetGlobalProjects {
    name: string;
}
export interface Response$GetGlobalProjects$Status$200 {
    "application/json": Schemas.projectGlobalProjectsResponse;
}
export interface Parameter$GetSyncWindowsState {
    name: string;
}
export interface Response$GetSyncWindowsState$Status$200 {
    "application/json": Schemas.projectSyncWindowsResponse;
}
export interface Parameter$UpdateMixin5 {
    /**
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: http://kubernetes.io/docs/user-guide/identifiers#names
     * +optional
     */
    "project.metadata.name": string;
}
export interface RequestBody$UpdateMixin5 {
    "application/json": Schemas.projectProjectUpdateRequest;
}
export interface Response$UpdateMixin5$Status$200 {
    "application/json": Schemas.v1alpha1AppProject;
}
export interface Parameter$CreateTokenMixin5 {
    project: string;
    role: string;
}
export interface RequestBody$CreateTokenMixin5 {
    "application/json": Schemas.projectProjectTokenCreateRequest;
}
export interface Response$CreateTokenMixin5$Status$200 {
    "application/json": Schemas.projectProjectTokenResponse;
}
export interface Parameter$DeleteTokenMixin5 {
    project: string;
    role: string;
    iat: string;
    id?: string;
}
export interface Response$DeleteTokenMixin5$Status$200 {
    "application/json": Schemas.projectEmptyResponse;
}
export interface Parameter$ListRepositoryCredentials {
    /** Repo URL for query. */
    url?: string;
}
export interface Response$ListRepositoryCredentials$Status$200 {
    "application/json": Schemas.v1alpha1RepoCredsList;
}
export interface RequestBody$CreateRepositoryCredentials {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Response$CreateRepositoryCredentials$Status$200 {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Parameter$UpdateRepositoryCredentials {
    /** URL is the URL that this credentials matches to */
    "creds.url": string;
}
export interface RequestBody$UpdateRepositoryCredentials {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Response$UpdateRepositoryCredentials$Status$200 {
    "application/json": Schemas.v1alpha1RepoCreds;
}
export interface Parameter$DeleteRepositoryCredentials {
    url: string;
}
export interface Response$DeleteRepositoryCredentials$Status$200 {
    "application/json": Schemas.repocredsRepoCredsResponse;
}
export interface Parameter$ListRepositories {
    /** Repo URL for query. */
    repo?: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$ListRepositories$Status$200 {
    "application/json": Schemas.v1alpha1RepositoryList;
}
export interface RequestBody$CreateRepository {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$CreateRepository$Status$200 {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Parameter$UpdateRepository {
    /** URL of the repo */
    "repo.repo": string;
}
export interface RequestBody$UpdateRepository {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Response$UpdateRepository$Status$200 {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Parameter$GetMixin7 {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$GetMixin7$Status$200 {
    "application/json": Schemas.v1alpha1Repository;
}
export interface Parameter$DeleteRepository {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$DeleteRepository$Status$200 {
    "application/json": Schemas.repositoryRepoResponse;
}
export interface Parameter$ListApps {
    repo: string;
    revision?: string;
}
export interface Response$ListApps$Status$200 {
    "application/json": Schemas.repositoryRepoAppsResponse;
}
export interface Parameter$GetHelmCharts {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$GetHelmCharts$Status$200 {
    "application/json": Schemas.repositoryHelmChartsResponse;
}
export interface Parameter$ListRefs {
    /** Repo URL for query */
    repo: string;
    /** Whether to force a cache refresh on repo's connection state. */
    forceRefresh?: boolean;
}
export interface Response$ListRefs$Status$200 {
    "application/json": Schemas.repositoryRefs;
}
export interface Parameter$ValidateAccess {
    /** The URL to the repo */
    repo: string;
}
export interface RequestBody$ValidateAccess {
    "application/json": string;
}
export interface Response$ValidateAccess$Status$200 {
    "application/json": Schemas.repositoryRepoResponse;
}
export interface Parameter$GetAppDetails {
    /** RepoURL is the repository URL of the application manifests */
    "source.repoURL": string;
}
export interface RequestBody$GetAppDetails {
    "application/json": Schemas.repositoryRepoAppDetailsQuery;
}
export interface Response$GetAppDetails$Status$200 {
    "application/json": Schemas.repositoryRepoAppDetailsResponse;
}
export interface RequestBody$CreateMixin8 {
    "application/json": Schemas.sessionSessionCreateRequest;
}
export interface Response$CreateMixin8$Status$200 {
    "application/json": Schemas.sessionSessionResponse;
}
export interface Response$DeleteMixin8$Status$200 {
    "application/json": Schemas.sessionSessionResponse;
}
export interface Response$GetUserInfo$Status$200 {
    "application/json": Schemas.sessionGetUserInfoResponse;
}
export interface Response$GetMixin10$Status$200 {
    "application/json": Schemas.clusterSettings;
}
export interface Parameter$Watch {
    /** the application's name. */
    name?: string;
    /** forces application reconciliation if set to true. */
    refresh?: string;
    /** the project names to restrict returned list applications. */
    project?: string[];
    /** when specified with a watch call, shows changes that occur after that particular version of a resource. */
    resourceVersion?: string;
    /** the selector to to restrict returned list to applications only with matched labels. */
    selector?: string;
}
export interface Response$Watch$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.v1alpha1ApplicationWatchEvent;
    };
}
export interface Parameter$WatchResourceTree {
    applicationName: string;
    namespace?: string;
    name?: string;
    version?: string;
    group?: string;
    kind?: string;
}
export interface Response$WatchResourceTree$Status$200 {
    "application/json": {
        error?: Schemas.runtimeStreamError;
        result?: Schemas.v1alpha1ApplicationTree;
    };
}
export interface Response$Version$Status$200 {
    "application/json": Schemas.versionVersionMessage;
}
export type ResponseContentType$ListAccounts = keyof Response$ListAccounts$Status$200;
export type ResponseContentType$CanI = keyof Response$CanI$Status$200;
export interface Params$CanI {
    parameter: Parameter$CanI;
}
export type RequestContentType$UpdatePassword = keyof RequestBody$UpdatePassword;
export type ResponseContentType$UpdatePassword = keyof Response$UpdatePassword$Status$200;
export interface Params$UpdatePassword {
    requestBody: RequestBody$UpdatePassword["application/json"];
}
export type ResponseContentType$GetAccount = keyof Response$GetAccount$Status$200;
export interface Params$GetAccount {
    parameter: Parameter$GetAccount;
}
export type RequestContentType$CreateToken = keyof RequestBody$CreateToken;
export type ResponseContentType$CreateToken = keyof Response$CreateToken$Status$200;
export interface Params$CreateToken {
    parameter: Parameter$CreateToken;
    requestBody: RequestBody$CreateToken["application/json"];
}
export type ResponseContentType$DeleteToken = keyof Response$DeleteToken$Status$200;
export interface Params$DeleteToken {
    parameter: Parameter$DeleteToken;
}
export type ResponseContentType$List = keyof Response$List$Status$200;
export interface Params$List {
    parameter: Parameter$List;
}
export type RequestContentType$Create = keyof RequestBody$Create;
export type ResponseContentType$Create = keyof Response$Create$Status$200;
export interface Params$Create {
    requestBody: RequestBody$Create["application/json"];
}
export type RequestContentType$Update = keyof RequestBody$Update;
export type ResponseContentType$Update = keyof Response$Update$Status$200;
export interface Params$Update {
    parameter: Parameter$Update;
    requestBody: RequestBody$Update["application/json"];
}
export type ResponseContentType$ManagedResources = keyof Response$ManagedResources$Status$200;
export interface Params$ManagedResources {
    parameter: Parameter$ManagedResources;
}
export type ResponseContentType$ResourceTree = keyof Response$ResourceTree$Status$200;
export interface Params$ResourceTree {
    parameter: Parameter$ResourceTree;
}
export type ResponseContentType$Get = keyof Response$Get$Status$200;
export interface Params$Get {
    parameter: Parameter$Get;
}
export type ResponseContentType$Delete = keyof Response$Delete$Status$200;
export interface Params$Delete {
    parameter: Parameter$Delete;
}
export type RequestContentType$Patch = keyof RequestBody$Patch;
export type ResponseContentType$Patch = keyof Response$Patch$Status$200;
export interface Params$Patch {
    parameter: Parameter$Patch;
    requestBody: RequestBody$Patch["application/json"];
}
export type ResponseContentType$ListResourceEvents = keyof Response$ListResourceEvents$Status$200;
export interface Params$ListResourceEvents {
    parameter: Parameter$ListResourceEvents;
}
export type ResponseContentType$GetManifests = keyof Response$GetManifests$Status$200;
export interface Params$GetManifests {
    parameter: Parameter$GetManifests;
}
export type ResponseContentType$TerminateOperation = keyof Response$TerminateOperation$Status$200;
export interface Params$TerminateOperation {
    parameter: Parameter$TerminateOperation;
}
export type ResponseContentType$PodLogs = keyof Response$PodLogs$Status$200;
export interface Params$PodLogs {
    parameter: Parameter$PodLogs;
}
export type ResponseContentType$GetResource = keyof Response$GetResource$Status$200;
export interface Params$GetResource {
    parameter: Parameter$GetResource;
}
export type RequestContentType$PatchResource = keyof RequestBody$PatchResource;
export type ResponseContentType$PatchResource = keyof Response$PatchResource$Status$200;
export interface Params$PatchResource {
    parameter: Parameter$PatchResource;
    requestBody: RequestBody$PatchResource["application/json"];
}
export type ResponseContentType$DeleteResource = keyof Response$DeleteResource$Status$200;
export interface Params$DeleteResource {
    parameter: Parameter$DeleteResource;
}
export type ResponseContentType$ListResourceActions = keyof Response$ListResourceActions$Status$200;
export interface Params$ListResourceActions {
    parameter: Parameter$ListResourceActions;
}
export type RequestContentType$RunResourceAction = keyof RequestBody$RunResourceAction;
export type ResponseContentType$RunResourceAction = keyof Response$RunResourceAction$Status$200;
export interface Params$RunResourceAction {
    parameter: Parameter$RunResourceAction;
    requestBody: RequestBody$RunResourceAction["application/json"];
}
export type ResponseContentType$RevisionMetadata = keyof Response$RevisionMetadata$Status$200;
export interface Params$RevisionMetadata {
    parameter: Parameter$RevisionMetadata;
}
export type RequestContentType$Rollback = keyof RequestBody$Rollback;
export type ResponseContentType$Rollback = keyof Response$Rollback$Status$200;
export interface Params$Rollback {
    parameter: Parameter$Rollback;
    requestBody: RequestBody$Rollback["application/json"];
}
export type RequestContentType$UpdateSpec = keyof RequestBody$UpdateSpec;
export type ResponseContentType$UpdateSpec = keyof Response$UpdateSpec$Status$200;
export interface Params$UpdateSpec {
    parameter: Parameter$UpdateSpec;
    requestBody: RequestBody$UpdateSpec["application/json"];
}
export type RequestContentType$Sync = keyof RequestBody$Sync;
export type ResponseContentType$Sync = keyof Response$Sync$Status$200;
export interface Params$Sync {
    parameter: Parameter$Sync;
    requestBody: RequestBody$Sync["application/json"];
}
export type ResponseContentType$GetApplicationSyncWindows = keyof Response$GetApplicationSyncWindows$Status$200;
export interface Params$GetApplicationSyncWindows {
    parameter: Parameter$GetApplicationSyncWindows;
}
export type ResponseContentType$ListCertificates = keyof Response$ListCertificates$Status$200;
export interface Params$ListCertificates {
    parameter: Parameter$ListCertificates;
}
export type RequestContentType$CreateCertificate = keyof RequestBody$CreateCertificate;
export type ResponseContentType$CreateCertificate = keyof Response$CreateCertificate$Status$200;
export interface Params$CreateCertificate {
    requestBody: RequestBody$CreateCertificate["application/json"];
}
export type ResponseContentType$DeleteCertificate = keyof Response$DeleteCertificate$Status$200;
export interface Params$DeleteCertificate {
    parameter: Parameter$DeleteCertificate;
}
export type ResponseContentType$ListMixin3 = keyof Response$ListMixin3$Status$200;
export interface Params$ListMixin3 {
    parameter: Parameter$ListMixin3;
}
export type RequestContentType$CreateMixin3 = keyof RequestBody$CreateMixin3;
export type ResponseContentType$CreateMixin3 = keyof Response$CreateMixin3$Status$200;
export interface Params$CreateMixin3 {
    requestBody: RequestBody$CreateMixin3["application/json"];
}
export type RequestContentType$UpdateMixin3 = keyof RequestBody$UpdateMixin3;
export type ResponseContentType$UpdateMixin3 = keyof Response$UpdateMixin3$Status$200;
export interface Params$UpdateMixin3 {
    parameter: Parameter$UpdateMixin3;
    requestBody: RequestBody$UpdateMixin3["application/json"];
}
export type ResponseContentType$GetMixin3 = keyof Response$GetMixin3$Status$200;
export interface Params$GetMixin3 {
    parameter: Parameter$GetMixin3;
}
export type ResponseContentType$DeleteMixin3 = keyof Response$DeleteMixin3$Status$200;
export interface Params$DeleteMixin3 {
    parameter: Parameter$DeleteMixin3;
}
export type ResponseContentType$InvalidateCache = keyof Response$InvalidateCache$Status$200;
export interface Params$InvalidateCache {
    parameter: Parameter$InvalidateCache;
}
export type ResponseContentType$RotateAuth = keyof Response$RotateAuth$Status$200;
export interface Params$RotateAuth {
    parameter: Parameter$RotateAuth;
}
export type ResponseContentType$ListMixin4 = keyof Response$ListMixin4$Status$200;
export interface Params$ListMixin4 {
    parameter: Parameter$ListMixin4;
}
export type RequestContentType$CreateMixin4 = keyof RequestBody$CreateMixin4;
export type ResponseContentType$CreateMixin4 = keyof Response$CreateMixin4$Status$200;
export interface Params$CreateMixin4 {
    requestBody: RequestBody$CreateMixin4["application/json"];
}
export type ResponseContentType$DeleteMixin4 = keyof Response$DeleteMixin4$Status$200;
export interface Params$DeleteMixin4 {
    parameter: Parameter$DeleteMixin4;
}
export type ResponseContentType$GetMixin4 = keyof Response$GetMixin4$Status$200;
export interface Params$GetMixin4 {
    parameter: Parameter$GetMixin4;
}
export type ResponseContentType$ListMixin5 = keyof Response$ListMixin5$Status$200;
export interface Params$ListMixin5 {
    parameter: Parameter$ListMixin5;
}
export type RequestContentType$CreateMixin5 = keyof RequestBody$CreateMixin5;
export type ResponseContentType$CreateMixin5 = keyof Response$CreateMixin5$Status$200;
export interface Params$CreateMixin5 {
    requestBody: RequestBody$CreateMixin5["application/json"];
}
export type ResponseContentType$GetMixin5 = keyof Response$GetMixin5$Status$200;
export interface Params$GetMixin5 {
    parameter: Parameter$GetMixin5;
}
export type ResponseContentType$DeleteMixin5 = keyof Response$DeleteMixin5$Status$200;
export interface Params$DeleteMixin5 {
    parameter: Parameter$DeleteMixin5;
}
export type ResponseContentType$ListEvents = keyof Response$ListEvents$Status$200;
export interface Params$ListEvents {
    parameter: Parameter$ListEvents;
}
export type ResponseContentType$GetGlobalProjects = keyof Response$GetGlobalProjects$Status$200;
export interface Params$GetGlobalProjects {
    parameter: Parameter$GetGlobalProjects;
}
export type ResponseContentType$GetSyncWindowsState = keyof Response$GetSyncWindowsState$Status$200;
export interface Params$GetSyncWindowsState {
    parameter: Parameter$GetSyncWindowsState;
}
export type RequestContentType$UpdateMixin5 = keyof RequestBody$UpdateMixin5;
export type ResponseContentType$UpdateMixin5 = keyof Response$UpdateMixin5$Status$200;
export interface Params$UpdateMixin5 {
    parameter: Parameter$UpdateMixin5;
    requestBody: RequestBody$UpdateMixin5["application/json"];
}
export type RequestContentType$CreateTokenMixin5 = keyof RequestBody$CreateTokenMixin5;
export type ResponseContentType$CreateTokenMixin5 = keyof Response$CreateTokenMixin5$Status$200;
export interface Params$CreateTokenMixin5 {
    parameter: Parameter$CreateTokenMixin5;
    requestBody: RequestBody$CreateTokenMixin5["application/json"];
}
export type ResponseContentType$DeleteTokenMixin5 = keyof Response$DeleteTokenMixin5$Status$200;
export interface Params$DeleteTokenMixin5 {
    parameter: Parameter$DeleteTokenMixin5;
}
export type ResponseContentType$ListRepositoryCredentials = keyof Response$ListRepositoryCredentials$Status$200;
export interface Params$ListRepositoryCredentials {
    parameter: Parameter$ListRepositoryCredentials;
}
export type RequestContentType$CreateRepositoryCredentials = keyof RequestBody$CreateRepositoryCredentials;
export type ResponseContentType$CreateRepositoryCredentials = keyof Response$CreateRepositoryCredentials$Status$200;
export interface Params$CreateRepositoryCredentials {
    requestBody: RequestBody$CreateRepositoryCredentials["application/json"];
}
export type RequestContentType$UpdateRepositoryCredentials = keyof RequestBody$UpdateRepositoryCredentials;
export type ResponseContentType$UpdateRepositoryCredentials = keyof Response$UpdateRepositoryCredentials$Status$200;
export interface Params$UpdateRepositoryCredentials {
    parameter: Parameter$UpdateRepositoryCredentials;
    requestBody: RequestBody$UpdateRepositoryCredentials["application/json"];
}
export type ResponseContentType$DeleteRepositoryCredentials = keyof Response$DeleteRepositoryCredentials$Status$200;
export interface Params$DeleteRepositoryCredentials {
    parameter: Parameter$DeleteRepositoryCredentials;
}
export type ResponseContentType$ListRepositories = keyof Response$ListRepositories$Status$200;
export interface Params$ListRepositories {
    parameter: Parameter$ListRepositories;
}
export type RequestContentType$CreateRepository = keyof RequestBody$CreateRepository;
export type ResponseContentType$CreateRepository = keyof Response$CreateRepository$Status$200;
export interface Params$CreateRepository {
    requestBody: RequestBody$CreateRepository["application/json"];
}
export type RequestContentType$UpdateRepository = keyof RequestBody$UpdateRepository;
export type ResponseContentType$UpdateRepository = keyof Response$UpdateRepository$Status$200;
export interface Params$UpdateRepository {
    parameter: Parameter$UpdateRepository;
    requestBody: RequestBody$UpdateRepository["application/json"];
}
export type ResponseContentType$GetMixin7 = keyof Response$GetMixin7$Status$200;
export interface Params$GetMixin7 {
    parameter: Parameter$GetMixin7;
}
export type ResponseContentType$DeleteRepository = keyof Response$DeleteRepository$Status$200;
export interface Params$DeleteRepository {
    parameter: Parameter$DeleteRepository;
}
export type ResponseContentType$ListApps = keyof Response$ListApps$Status$200;
export interface Params$ListApps {
    parameter: Parameter$ListApps;
}
export type ResponseContentType$GetHelmCharts = keyof Response$GetHelmCharts$Status$200;
export interface Params$GetHelmCharts {
    parameter: Parameter$GetHelmCharts;
}
export type ResponseContentType$ListRefs = keyof Response$ListRefs$Status$200;
export interface Params$ListRefs {
    parameter: Parameter$ListRefs;
}
export type RequestContentType$ValidateAccess = keyof RequestBody$ValidateAccess;
export type ResponseContentType$ValidateAccess = keyof Response$ValidateAccess$Status$200;
export interface Params$ValidateAccess {
    parameter: Parameter$ValidateAccess;
    requestBody: RequestBody$ValidateAccess["application/json"];
}
export type RequestContentType$GetAppDetails = keyof RequestBody$GetAppDetails;
export type ResponseContentType$GetAppDetails = keyof Response$GetAppDetails$Status$200;
export interface Params$GetAppDetails {
    parameter: Parameter$GetAppDetails;
    requestBody: RequestBody$GetAppDetails["application/json"];
}
export type RequestContentType$CreateMixin8 = keyof RequestBody$CreateMixin8;
export type ResponseContentType$CreateMixin8 = keyof Response$CreateMixin8$Status$200;
export interface Params$CreateMixin8 {
    requestBody: RequestBody$CreateMixin8["application/json"];
}
export type ResponseContentType$DeleteMixin8 = keyof Response$DeleteMixin8$Status$200;
export type ResponseContentType$GetUserInfo = keyof Response$GetUserInfo$Status$200;
export type ResponseContentType$GetMixin10 = keyof Response$GetMixin10$Status$200;
export type ResponseContentType$Watch = keyof Response$Watch$Status$200;
export interface Params$Watch {
    parameter: Parameter$Watch;
}
export type ResponseContentType$WatchResourceTree = keyof Response$WatchResourceTree$Status$200;
export interface Params$WatchResourceTree {
    parameter: Parameter$WatchResourceTree;
}
export type ResponseContentType$Version = keyof Response$Version$Status$200;
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$ListAccounts$Status$200 | Response$CanI$Status$200 | Response$UpdatePassword$Status$200 | Response$GetAccount$Status$200 | Response$CreateToken$Status$200 | Response$DeleteToken$Status$200 | Response$List$Status$200 | Response$Create$Status$200 | Response$Update$Status$200 | Response$ManagedResources$Status$200 | Response$ResourceTree$Status$200 | Response$Get$Status$200 | Response$Delete$Status$200 | Response$Patch$Status$200 | Response$ListResourceEvents$Status$200 | Response$GetManifests$Status$200 | Response$TerminateOperation$Status$200 | Response$PodLogs$Status$200 | Response$GetResource$Status$200 | Response$PatchResource$Status$200 | Response$DeleteResource$Status$200 | Response$ListResourceActions$Status$200 | Response$RunResourceAction$Status$200 | Response$RevisionMetadata$Status$200 | Response$Rollback$Status$200 | Response$UpdateSpec$Status$200 | Response$Sync$Status$200 | Response$GetApplicationSyncWindows$Status$200 | Response$ListCertificates$Status$200 | Response$CreateCertificate$Status$200 | Response$DeleteCertificate$Status$200 | Response$ListMixin3$Status$200 | Response$CreateMixin3$Status$200 | Response$UpdateMixin3$Status$200 | Response$GetMixin3$Status$200 | Response$DeleteMixin3$Status$200 | Response$InvalidateCache$Status$200 | Response$RotateAuth$Status$200 | Response$ListMixin4$Status$200 | Response$CreateMixin4$Status$200 | Response$DeleteMixin4$Status$200 | Response$GetMixin4$Status$200 | Response$ListMixin5$Status$200 | Response$CreateMixin5$Status$200 | Response$GetMixin5$Status$200 | Response$DeleteMixin5$Status$200 | Response$ListEvents$Status$200 | Response$GetGlobalProjects$Status$200 | Response$GetSyncWindowsState$Status$200 | Response$UpdateMixin5$Status$200 | Response$CreateTokenMixin5$Status$200 | Response$DeleteTokenMixin5$Status$200 | Response$ListRepositoryCredentials$Status$200 | Response$CreateRepositoryCredentials$Status$200 | Response$UpdateRepositoryCredentials$Status$200 | Response$DeleteRepositoryCredentials$Status$200 | Response$ListRepositories$Status$200 | Response$CreateRepository$Status$200 | Response$UpdateRepository$Status$200 | Response$GetMixin7$Status$200 | Response$DeleteRepository$Status$200 | Response$ListApps$Status$200 | Response$GetHelmCharts$Status$200 | Response$ListRefs$Status$200 | Response$ValidateAccess$Status$200 | Response$GetAppDetails$Status$200 | Response$CreateMixin8$Status$200 | Response$DeleteMixin8$Status$200 | Response$GetUserInfo$Status$200 | Response$GetMixin10$Status$200 | Response$Watch$Status$200 | Response$WatchResourceTree$Status$200 | Response$Version$Status$200;
export namespace ErrorResponse {
    export type ListAccounts = void;
    export type CanI = void;
    export type UpdatePassword = void;
    export type GetAccount = void;
    export type CreateToken = void;
    export type DeleteToken = void;
    export type List = void;
    export type Create = void;
    export type Update = void;
    export type ManagedResources = void;
    export type ResourceTree = void;
    export type Get = void;
    export type Delete = void;
    export type Patch = void;
    export type ListResourceEvents = void;
    export type GetManifests = void;
    export type TerminateOperation = void;
    export type PodLogs = void;
    export type GetResource = void;
    export type PatchResource = void;
    export type DeleteResource = void;
    export type ListResourceActions = void;
    export type RunResourceAction = void;
    export type RevisionMetadata = void;
    export type Rollback = void;
    export type UpdateSpec = void;
    export type Sync = void;
    export type GetApplicationSyncWindows = void;
    export type ListCertificates = void;
    export type CreateCertificate = void;
    export type DeleteCertificate = void;
    export type ListMixin3 = void;
    export type CreateMixin3 = void;
    export type UpdateMixin3 = void;
    export type GetMixin3 = void;
    export type DeleteMixin3 = void;
    export type InvalidateCache = void;
    export type RotateAuth = void;
    export type ListMixin4 = void;
    export type CreateMixin4 = void;
    export type DeleteMixin4 = void;
    export type GetMixin4 = void;
    export type ListMixin5 = void;
    export type CreateMixin5 = void;
    export type GetMixin5 = void;
    export type DeleteMixin5 = void;
    export type ListEvents = void;
    export type GetGlobalProjects = void;
    export type GetSyncWindowsState = void;
    export type UpdateMixin5 = void;
    export type CreateTokenMixin5 = void;
    export type DeleteTokenMixin5 = void;
    export type ListRepositoryCredentials = void;
    export type CreateRepositoryCredentials = void;
    export type UpdateRepositoryCredentials = void;
    export type DeleteRepositoryCredentials = void;
    export type ListRepositories = void;
    export type CreateRepository = void;
    export type UpdateRepository = void;
    export type GetMixin7 = void;
    export type DeleteRepository = void;
    export type ListApps = void;
    export type GetHelmCharts = void;
    export type ListRefs = void;
    export type ValidateAccess = void;
    export type GetAppDetails = void;
    export type CreateMixin8 = void;
    export type DeleteMixin8 = void;
    export type GetUserInfo = void;
    export type GetMixin10 = void;
    export type Watch = void;
    export type WatchResourceTree = void;
    export type Version = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\/$/, ""); }
    /**
     * ListAccounts returns the list of accounts
     * operationId: ListAccounts
     * Request URI: /api/v1/account
     */
    public async ListAccounts(option?: RequestOption): Promise<Response$ListAccounts$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * CanI checks if the current account has permission to perform an action
     * operationId: CanI
     * Request URI: /api/v1/account/can-i/{resource}/{action}/{subresource}
     */
    public async CanI(params: Params$CanI, option?: RequestOption): Promise<Response$CanI$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/can-i/${params.parameter.resource}/${params.parameter.action}/${params.parameter.subresource}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * UpdatePassword updates an account's password to a new value
     * operationId: UpdatePassword
     * Request URI: /api/v1/account/password
     */
    public async UpdatePassword(params: Params$UpdatePassword, option?: RequestOption): Promise<Response$UpdatePassword$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/password`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * GetAccount returns an account
     * operationId: GetAccount
     * Request URI: /api/v1/account/{name}
     */
    public async GetAccount(params: Params$GetAccount, option?: RequestOption): Promise<Response$GetAccount$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * CreateToken creates a token
     * operationId: CreateToken
     * Request URI: /api/v1/account/{name}/token
     */
    public async CreateToken(params: Params$CreateToken, option?: RequestOption): Promise<Response$CreateToken$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/${params.parameter.name}/token`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * DeleteToken deletes a token
     * operationId: DeleteToken
     * Request URI: /api/v1/account/{name}/token/{id}
     */
    public async DeleteToken(params: Params$DeleteToken, option?: RequestOption): Promise<Response$DeleteToken$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/account/${params.parameter.name}/token/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * List returns list of applications
     * operationId: List
     * Request URI: /api/v1/applications
     */
    public async List(params: Params$List, option?: RequestOption): Promise<Response$List$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            refresh: { value: params.parameter.refresh, explode: false },
            project: { value: params.parameter.project, explode: true },
            resourceVersion: { value: params.parameter.resourceVersion, explode: false },
            selector: { value: params.parameter.selector, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create creates an application
     * operationId: Create
     * Request URI: /api/v1/applications
     */
    public async Create(params: Params$Create, option?: RequestOption): Promise<Response$Create$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Update updates an application
     * operationId: Update
     * Request URI: /api/v1/applications/{application.metadata.name}
     */
    public async Update(params: Params$Update, option?: RequestOption): Promise<Response$Update$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter["application.metadata.name"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * ManagedResources returns list of managed resources
     * operationId: ManagedResources
     * Request URI: /api/v1/applications/{applicationName}/managed-resources
     */
    public async ManagedResources(params: Params$ManagedResources, option?: RequestOption): Promise<Response$ManagedResources$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.applicationName}/managed-resources`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            name: { value: params.parameter.name, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * ResourceTree returns resource tree
     * operationId: ResourceTree
     * Request URI: /api/v1/applications/{applicationName}/resource-tree
     */
    public async ResourceTree(params: Params$ResourceTree, option?: RequestOption): Promise<Response$ResourceTree$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.applicationName}/resource-tree`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            name: { value: params.parameter.name, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Get returns an application by name
     * operationId: Get
     * Request URI: /api/v1/applications/{name}
     */
    public async Get(params: Params$Get, option?: RequestOption): Promise<Response$Get$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            refresh: { value: params.parameter.refresh, explode: false },
            project: { value: params.parameter.project, explode: true },
            resourceVersion: { value: params.parameter.resourceVersion, explode: false },
            selector: { value: params.parameter.selector, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete deletes an application
     * operationId: Delete
     * Request URI: /api/v1/applications/{name}
     */
    public async Delete(params: Params$Delete, option?: RequestOption): Promise<Response$Delete$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            cascade: { value: params.parameter.cascade, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * Patch patch an application
     * operationId: Patch
     * Request URI: /api/v1/applications/{name}
     */
    public async Patch(params: Params$Patch, option?: RequestOption): Promise<Response$Patch$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * ListResourceEvents returns a list of event resources
     * operationId: ListResourceEvents
     * Request URI: /api/v1/applications/{name}/events
     */
    public async ListResourceEvents(params: Params$ListResourceEvents, option?: RequestOption): Promise<Response$ListResourceEvents$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/events`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            resourceNamespace: { value: params.parameter.resourceNamespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            resourceUID: { value: params.parameter.resourceUID, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * GetManifests returns application manifests
     * operationId: GetManifests
     * Request URI: /api/v1/applications/{name}/manifests
     */
    public async GetManifests(params: Params$GetManifests, option?: RequestOption): Promise<Response$GetManifests$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/manifests`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            revision: { value: params.parameter.revision, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * TerminateOperation terminates the currently running operation
     * operationId: TerminateOperation
     * Request URI: /api/v1/applications/{name}/operation
     */
    public async TerminateOperation(params: Params$TerminateOperation, option?: RequestOption): Promise<Response$TerminateOperation$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/operation`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * PodLogs returns stream of log entries for the specified pod. Pod
     * operationId: PodLogs
     * Request URI: /api/v1/applications/{name}/pods/{podName}/logs
     */
    public async PodLogs(params: Params$PodLogs, option?: RequestOption): Promise<Response$PodLogs$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/pods/${params.parameter.podName}/logs`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            container: { value: params.parameter.container, explode: false },
            sinceSeconds: { value: params.parameter.sinceSeconds, explode: false },
            "sinceTime.seconds": { value: params.parameter["sinceTime.seconds"], explode: false },
            "sinceTime.nanos": { value: params.parameter["sinceTime.nanos"], explode: false },
            tailLines: { value: params.parameter.tailLines, explode: false },
            follow: { value: params.parameter.follow, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * GetResource returns single application resource
     * operationId: GetResource
     * Request URI: /api/v1/applications/{name}/resource
     */
    public async GetResource(params: Params$GetResource, option?: RequestOption): Promise<Response$GetResource$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * PatchResource patch single application resource
     * operationId: PatchResource
     * Request URI: /api/v1/applications/{name}/resource
     */
    public async PatchResource(params: Params$PatchResource, option?: RequestOption): Promise<Response$PatchResource$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * DeleteResource deletes a single application resource
     * operationId: DeleteResource
     * Request URI: /api/v1/applications/{name}/resource
     */
    public async DeleteResource(params: Params$DeleteResource, option?: RequestOption): Promise<Response$DeleteResource$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false },
            force: { value: params.parameter.force, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * ListResourceActions returns list of resource actions
     * operationId: ListResourceActions
     * Request URI: /api/v1/applications/{name}/resource/actions
     */
    public async ListResourceActions(params: Params$ListResourceActions, option?: RequestOption): Promise<Response$ListResourceActions$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource/actions`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            resourceName: { value: params.parameter.resourceName, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * RunResourceAction run resource action
     * operationId: RunResourceAction
     * Request URI: /api/v1/applications/{name}/resource/actions
     */
    public async RunResourceAction(params: Params$RunResourceAction, option?: RequestOption): Promise<Response$RunResourceAction$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/resource/actions`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get the meta-data (author, date, tags, message) for a specific revision of the application
     * operationId: RevisionMetadata
     * Request URI: /api/v1/applications/{name}/revisions/{revision}/metadata
     */
    public async RevisionMetadata(params: Params$RevisionMetadata, option?: RequestOption): Promise<Response$RevisionMetadata$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/revisions/${params.parameter.revision}/metadata`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Rollback syncs an application to its target state
     * operationId: Rollback
     * Request URI: /api/v1/applications/{name}/rollback
     */
    public async Rollback(params: Params$Rollback, option?: RequestOption): Promise<Response$Rollback$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/rollback`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * UpdateSpec updates an application spec
     * operationId: UpdateSpec
     * Request URI: /api/v1/applications/{name}/spec
     */
    public async UpdateSpec(params: Params$UpdateSpec, option?: RequestOption): Promise<Response$UpdateSpec$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/spec`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Sync syncs an application to its target state
     * operationId: Sync
     * Request URI: /api/v1/applications/{name}/sync
     */
    public async Sync(params: Params$Sync, option?: RequestOption): Promise<Response$Sync$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/sync`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get returns sync windows of the application
     * operationId: GetApplicationSyncWindows
     * Request URI: /api/v1/applications/{name}/syncwindows
     */
    public async GetApplicationSyncWindows(params: Params$GetApplicationSyncWindows, option?: RequestOption): Promise<Response$GetApplicationSyncWindows$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/applications/${params.parameter.name}/syncwindows`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * List all available repository certificates
     * operationId: ListCertificates
     * Request URI: /api/v1/certificates
     */
    public async ListCertificates(params: Params$ListCertificates, option?: RequestOption): Promise<Response$ListCertificates$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/certificates`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            hostNamePattern: { value: params.parameter.hostNamePattern, explode: false },
            certType: { value: params.parameter.certType, explode: false },
            certSubType: { value: params.parameter.certSubType, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Creates repository certificates on the server
     * operationId: CreateCertificate
     * Request URI: /api/v1/certificates
     */
    public async CreateCertificate(params: Params$CreateCertificate, option?: RequestOption): Promise<Response$CreateCertificate$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/certificates`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete the certificates that match the RepositoryCertificateQuery
     * operationId: DeleteCertificate
     * Request URI: /api/v1/certificates
     */
    public async DeleteCertificate(params: Params$DeleteCertificate, option?: RequestOption): Promise<Response$DeleteCertificate$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/certificates`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            hostNamePattern: { value: params.parameter.hostNamePattern, explode: false },
            certType: { value: params.parameter.certType, explode: false },
            certSubType: { value: params.parameter.certSubType, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * List returns list of clusters
     * operationId: ListMixin3
     * Request URI: /api/v1/clusters
     */
    public async ListMixin3(params: Params$ListMixin3, option?: RequestOption): Promise<Response$ListMixin3$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            server: { value: params.parameter.server, explode: false },
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create creates a cluster
     * operationId: CreateMixin3
     * Request URI: /api/v1/clusters
     */
    public async CreateMixin3(params: Params$CreateMixin3, option?: RequestOption): Promise<Response$CreateMixin3$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Update updates a cluster
     * operationId: UpdateMixin3
     * Request URI: /api/v1/clusters/{cluster.server}
     */
    public async UpdateMixin3(params: Params$UpdateMixin3, option?: RequestOption): Promise<Response$UpdateMixin3$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter["cluster.server"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get returns a cluster by server address
     * operationId: GetMixin3
     * Request URI: /api/v1/clusters/{server}
     */
    public async GetMixin3(params: Params$GetMixin3, option?: RequestOption): Promise<Response$GetMixin3$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete deletes a cluster
     * operationId: DeleteMixin3
     * Request URI: /api/v1/clusters/{server}
     */
    public async DeleteMixin3(params: Params$DeleteMixin3, option?: RequestOption): Promise<Response$DeleteMixin3$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * InvalidateCache invalidates cluster cache
     * operationId: InvalidateCache
     * Request URI: /api/v1/clusters/{server}/invalidate-cache
     */
    public async InvalidateCache(params: Params$InvalidateCache, option?: RequestOption): Promise<Response$InvalidateCache$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}/invalidate-cache`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, undefined, undefined, option);
    }
    /**
     * RotateAuth rotates the bearer token used for a cluster
     * operationId: RotateAuth
     * Request URI: /api/v1/clusters/{server}/rotate-auth
     */
    public async RotateAuth(params: Params$RotateAuth, option?: RequestOption): Promise<Response$RotateAuth$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/clusters/${params.parameter.server}/rotate-auth`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, undefined, undefined, option);
    }
    /**
     * List all available repository certificates
     * operationId: ListMixin4
     * Request URI: /api/v1/gpgkeys
     */
    public async ListMixin4(params: Params$ListMixin4, option?: RequestOption): Promise<Response$ListMixin4$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            keyID: { value: params.parameter.keyID, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create one or more GPG public keys in the server's configuration
     * operationId: CreateMixin4
     * Request URI: /api/v1/gpgkeys
     */
    public async CreateMixin4(params: Params$CreateMixin4, option?: RequestOption): Promise<Response$CreateMixin4$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete specified GPG public key from the server's configuration
     * operationId: DeleteMixin4
     * Request URI: /api/v1/gpgkeys
     */
    public async DeleteMixin4(params: Params$DeleteMixin4, option?: RequestOption): Promise<Response$DeleteMixin4$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            keyID: { value: params.parameter.keyID, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * Get information about specified GPG public key from the server
     * operationId: GetMixin4
     * Request URI: /api/v1/gpgkeys/{keyID}
     */
    public async GetMixin4(params: Params$GetMixin4, option?: RequestOption): Promise<Response$GetMixin4$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/gpgkeys/${params.parameter.keyID}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * List returns list of projects
     * operationId: ListMixin5
     * Request URI: /api/v1/projects
     */
    public async ListMixin5(params: Params$ListMixin5, option?: RequestOption): Promise<Response$ListMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create a new project
     * operationId: CreateMixin5
     * Request URI: /api/v1/projects
     */
    public async CreateMixin5(params: Params$CreateMixin5, option?: RequestOption): Promise<Response$CreateMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get returns a project by name
     * operationId: GetMixin5
     * Request URI: /api/v1/projects/{name}
     */
    public async GetMixin5(params: Params$GetMixin5, option?: RequestOption): Promise<Response$GetMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete deletes a project
     * operationId: DeleteMixin5
     * Request URI: /api/v1/projects/{name}
     */
    public async DeleteMixin5(params: Params$DeleteMixin5, option?: RequestOption): Promise<Response$DeleteMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * ListEvents returns a list of project events
     * operationId: ListEvents
     * Request URI: /api/v1/projects/{name}/events
     */
    public async ListEvents(params: Params$ListEvents, option?: RequestOption): Promise<Response$ListEvents$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/events`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Get returns a virtual project by name
     * operationId: GetGlobalProjects
     * Request URI: /api/v1/projects/{name}/globalprojects
     */
    public async GetGlobalProjects(params: Params$GetGlobalProjects, option?: RequestOption): Promise<Response$GetGlobalProjects$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/globalprojects`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * GetSchedulesState returns true if there are any active sync syncWindows
     * operationId: GetSyncWindowsState
     * Request URI: /api/v1/projects/{name}/syncwindows
     */
    public async GetSyncWindowsState(params: Params$GetSyncWindowsState, option?: RequestOption): Promise<Response$GetSyncWindowsState$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.name}/syncwindows`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Update updates a project
     * operationId: UpdateMixin5
     * Request URI: /api/v1/projects/{project.metadata.name}
     */
    public async UpdateMixin5(params: Params$UpdateMixin5, option?: RequestOption): Promise<Response$UpdateMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter["project.metadata.name"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Create a new project token
     * operationId: CreateTokenMixin5
     * Request URI: /api/v1/projects/{project}/roles/{role}/token
     */
    public async CreateTokenMixin5(params: Params$CreateTokenMixin5, option?: RequestOption): Promise<Response$CreateTokenMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.project}/roles/${params.parameter.role}/token`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete a new project token
     * operationId: DeleteTokenMixin5
     * Request URI: /api/v1/projects/{project}/roles/{role}/token/{iat}
     */
    public async DeleteTokenMixin5(params: Params$DeleteTokenMixin5, option?: RequestOption): Promise<Response$DeleteTokenMixin5$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/projects/${params.parameter.project}/roles/${params.parameter.role}/token/${params.parameter.iat}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            id: { value: params.parameter.id, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * ListRepositoryCredentials gets a list of all configured repository credential sets
     * operationId: ListRepositoryCredentials
     * Request URI: /api/v1/repocreds
     */
    public async ListRepositoryCredentials(params: Params$ListRepositoryCredentials, option?: RequestOption): Promise<Response$ListRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            url: { value: params.parameter.url, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * CreateRepositoryCredentials creates a new repository credential set
     * operationId: CreateRepositoryCredentials
     * Request URI: /api/v1/repocreds
     */
    public async CreateRepositoryCredentials(params: Params$CreateRepositoryCredentials, option?: RequestOption): Promise<Response$CreateRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * UpdateRepositoryCredentials updates a repository credential set
     * operationId: UpdateRepositoryCredentials
     * Request URI: /api/v1/repocreds/{creds.url}
     */
    public async UpdateRepositoryCredentials(params: Params$UpdateRepositoryCredentials, option?: RequestOption): Promise<Response$UpdateRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds/${params.parameter["creds.url"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * DeleteRepositoryCredentials deletes a repository credential set from the configuration
     * operationId: DeleteRepositoryCredentials
     * Request URI: /api/v1/repocreds/{url}
     */
    public async DeleteRepositoryCredentials(params: Params$DeleteRepositoryCredentials, option?: RequestOption): Promise<Response$DeleteRepositoryCredentials$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repocreds/${params.parameter.url}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * ListRepositories gets a list of all configured repositories
     * operationId: ListRepositories
     * Request URI: /api/v1/repositories
     */
    public async ListRepositories(params: Params$ListRepositories, option?: RequestOption): Promise<Response$ListRepositories$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            repo: { value: params.parameter.repo, explode: false },
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * CreateRepository creates a new repository configuration
     * operationId: CreateRepository
     * Request URI: /api/v1/repositories
     */
    public async CreateRepository(params: Params$CreateRepository, option?: RequestOption): Promise<Response$CreateRepository$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * UpdateRepository updates a repository configuration
     * operationId: UpdateRepository
     * Request URI: /api/v1/repositories/{repo.repo}
     */
    public async UpdateRepository(params: Params$UpdateRepository, option?: RequestOption): Promise<Response$UpdateRepository$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter["repo.repo"]}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get returns a repository or its credentials
     * operationId: GetMixin7
     * Request URI: /api/v1/repositories/{repo}
     */
    public async GetMixin7(params: Params$GetMixin7, option?: RequestOption): Promise<Response$GetMixin7$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * DeleteRepository deletes a repository from the configuration
     * operationId: DeleteRepository
     * Request URI: /api/v1/repositories/{repo}
     */
    public async DeleteRepository(params: Params$DeleteRepository, option?: RequestOption): Promise<Response$DeleteRepository$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request("DELETE", url, headers, undefined, queryParameters, option);
    }
    /**
     * ListApps returns list of apps in the repe
     * operationId: ListApps
     * Request URI: /api/v1/repositories/{repo}/apps
     */
    public async ListApps(params: Params$ListApps, option?: RequestOption): Promise<Response$ListApps$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/apps`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            revision: { value: params.parameter.revision, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * GetHelmCharts returns list of helm charts in the specified repository
     * operationId: GetHelmCharts
     * Request URI: /api/v1/repositories/{repo}/helmcharts
     */
    public async GetHelmCharts(params: Params$GetHelmCharts, option?: RequestOption): Promise<Response$GetHelmCharts$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/helmcharts`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * operationId: ListRefs
     * Request URI: /api/v1/repositories/{repo}/refs
     */
    public async ListRefs(params: Params$ListRefs, option?: RequestOption): Promise<Response$ListRefs$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/refs`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            forceRefresh: { value: params.parameter.forceRefresh, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * ValidateAccess validates access to a repository with given parameters
     * operationId: ValidateAccess
     * Request URI: /api/v1/repositories/{repo}/validate
     */
    public async ValidateAccess(params: Params$ValidateAccess, option?: RequestOption): Promise<Response$ValidateAccess$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter.repo}/validate`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * GetAppDetails returns application details by given path
     * operationId: GetAppDetails
     * Request URI: /api/v1/repositories/{source.repoURL}/appdetails
     */
    public async GetAppDetails(params: Params$GetAppDetails, option?: RequestOption): Promise<Response$GetAppDetails$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/repositories/${params.parameter["source.repoURL"]}/appdetails`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Create a new JWT for authentication and set a cookie if using HTTP
     * operationId: CreateMixin8
     * Request URI: /api/v1/session
     */
    public async CreateMixin8(params: Params$CreateMixin8, option?: RequestOption): Promise<Response$CreateMixin8$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/session`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete an existing JWT cookie if using HTTP
     * operationId: DeleteMixin8
     * Request URI: /api/v1/session
     */
    public async DeleteMixin8(option?: RequestOption): Promise<Response$DeleteMixin8$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/session`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Get the current user's info
     * operationId: GetUserInfo
     * Request URI: /api/v1/session/userinfo
     */
    public async GetUserInfo(option?: RequestOption): Promise<Response$GetUserInfo$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/session/userinfo`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Get returns Argo CD settings
     * operationId: GetMixin10
     * Request URI: /api/v1/settings
     */
    public async GetMixin10(option?: RequestOption): Promise<Response$GetMixin10$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/settings`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Watch returns stream of application change events
     * operationId: Watch
     * Request URI: /api/v1/stream/applications
     */
    public async Watch(params: Params$Watch, option?: RequestOption): Promise<Response$Watch$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/stream/applications`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            refresh: { value: params.parameter.refresh, explode: false },
            project: { value: params.parameter.project, explode: true },
            resourceVersion: { value: params.parameter.resourceVersion, explode: false },
            selector: { value: params.parameter.selector, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Watch returns stream of application resource tree
     * operationId: WatchResourceTree
     * Request URI: /api/v1/stream/applications/{applicationName}/resource-tree
     */
    public async WatchResourceTree(params: Params$WatchResourceTree, option?: RequestOption): Promise<Response$WatchResourceTree$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v1/stream/applications/${params.parameter.applicationName}/resource-tree`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            namespace: { value: params.parameter.namespace, explode: false },
            name: { value: params.parameter.name, explode: false },
            version: { value: params.parameter.version, explode: false },
            group: { value: params.parameter.group, explode: false },
            kind: { value: params.parameter.kind, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Version returns version information of the API server
     * operationId: Version
     * Request URI: /api/version
     */
    public async Version(option?: RequestOption): Promise<Response$Version$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/version`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
}
